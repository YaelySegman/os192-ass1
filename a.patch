diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..a9d15ef
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,14 @@
+*.o
+*.d
+*.out
+*.sym
+*.asm
+_*
+xv6.img
+vectors.S
+mkfs
+bootblock
+entryother
+fs.img
+initcode
+kernel
diff --git a/204491112_RONENID.patch b/204491112_RONENID.patch
new file mode 100644
index 0000000..70cc3ff
--- /dev/null
+++ b/204491112_RONENID.patch
@@ -0,0 +1,2108 @@
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..a9d15ef
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1,14 @@
++*.o
++*.d
++*.out
++*.sym
++*.asm
++_*
++xv6.img
++vectors.S
++mkfs
++bootblock
++entryother
++fs.img
++initcode
++kernel
+diff --git a/Makefile b/Makefile
+index 920b6a3..d11b6e5 100644
+--- a/Makefile
++++ b/Makefile
+@@ -33,7 +33,7 @@ OBJS = \
+ # TOOLPREFIX = i386-elf-
+ 
+ # Using native tools (e.g., on X86 Linux)
+-#TOOLPREFIX = 
++#TOOLPREFIX =
+ 
+ # Try to infer the correct TOOLPREFIX if not set
+ ifndef TOOLPREFIX
+@@ -141,7 +141,7 @@ kernel: $(OBJS) entry.o entryother initcode kernel.ld
+ 	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+ 
+ ass1ds.o:
+-	$(GPP) $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
++	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+ 
+ # kernelmemfs is a copy of kernel that maintains the
+ # disk image in memory instead of writing to a disk.
+@@ -198,13 +198,15 @@ UPROGS=\
+ 	_stressfs\
+ 	_wc\
+ 	_zombie\
+-
+-fs.img: mkfs README $(UPROGS)
+-	./mkfs fs.img README $(UPROGS)
++	_tests\
++	_test\
++	
++fs.img: mkfs README  $(UPROGS)
++	./mkfs fs.img README  $(UPROGS)
+ 
+ -include *.d
+ 
+-clean: 
++clean:
+ 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+ 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+ 	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+diff --git a/ass1ds.cpp b/ass1ds.cpp
+index b93fb11..17f54d4 100644
+--- a/ass1ds.cpp
++++ b/ass1ds.cpp
+@@ -2,9 +2,11 @@
+ 
+ extern "C" {
+ 	char*                         kalloc();
++	void                          panic(char*) __attribute__((noreturn));
+ 	void*                         memset(void*, int, uint);
+ 	void                          initSchedDS();
+ 	long long                     getAccumulator(Proc *p);
++	long long                     __moddi3(long long number, long long divisor);
+ 
+ 	//for pq
+ 	static boolean                isEmptyPriorityQueue();
+@@ -212,7 +214,7 @@ static MapNode* allocNode(Proc *p, long long key) {
+ 	if(!ans)
+ 		return null;
+ 
+-	if(!ans->listOfProcs.enqueue(p)){
++	if(!ans->listOfProcs.enqueue(p)) {
+ 		deallocNode(ans);
+ 		return null;
+ 	}
+@@ -305,14 +307,16 @@ bool LinkedList::transfer() {
+ 	if(!priorityQ->isEmpty())
+ 		return false;
+ 	
+-	MapNode *node = allocNode(0);
+-	if(!node)
+-		return false;
+-	
+-	node->listOfProcs.first = first;
+-	node->listOfProcs.last = last;
+-	first = last = null;
+-	priorityQ->root = node;
++	if(!isEmpty()) {
++		MapNode *node = allocNode(0);
++		if(!node)
++			return false;
++		
++		node->listOfProcs.first = first;
++		node->listOfProcs.last = last;
++		first = last = null;
++		priorityQ->root = node;
++	}
+ 	return true;
+ }
+ 
+@@ -459,3 +463,29 @@ bool Map::extractProc(Proc *p) {
+ 	root = tempMap.root;
+ 	return ans;
+ }
++
++long long __moddi3(long long number, long long divisor) { //returns number%divisor
++	if(divisor == 0)
++		panic((char*)"divide by zero!!!\n");
++
++	bool isNumberNegative = false;
++	if(number < 0) {
++		number = -number;
++		isNumberNegative = true;
++	}
++
++	if(divisor < 0)
++		divisor = -divisor;
++
++	for(;;) {
++		long long divisor2 = divisor;
++		while(number >= divisor2) {
++			number -= divisor2;
++			if(divisor2 + divisor2 > 0) //exponential decay.
++				divisor2 += divisor2;
++		}
++
++		if(number < divisor)
++			return isNumberNegative ? -number : number;
++	}
++}
+diff --git a/cat.c b/cat.c
+index 5ddc820..ed1987d 100644
+--- a/cat.c
++++ b/cat.c
+@@ -12,12 +12,12 @@ cat(int fd)
+   while((n = read(fd, buf, sizeof(buf))) > 0) {
+     if (write(1, buf, n) != n) {
+       printf(1, "cat: write error\n");
+-      exit();
++      exit(0);
+     }
+   }
+   if(n < 0){
+     printf(1, "cat: read error\n");
+-    exit();
++    exit(0);
+   }
+ }
+ 
+@@ -28,16 +28,16 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     cat(0);
+-    exit();
++    exit(0);
+   }
+ 
+   for(i = 1; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit();
++      exit(0);
+     }
+     cat(fd);
+     close(fd);
+   }
+-  exit();
++  exit(0);
+ }
+diff --git a/defs.h b/defs.h
+index 82fb982..a120ec0 100644
+--- a/defs.h
++++ b/defs.h
+@@ -104,7 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
+ //PAGEBREAK: 16
+ // proc.c
+ int             cpuid(void);
+-void            exit(void);
++void            exit(int status);
+ int             fork(void);
+ int             growproc(int);
+ int             kill(int);
+@@ -117,9 +117,12 @@ void            sched(void);
+ void            setproc(struct proc*);
+ void            sleep(void*, struct spinlock*);
+ void            userinit(void);
+-int             wait(void);
++int             wait(int *status);
+ void            wakeup(void*);
+ void            yield(void);
++int             detach(int pid);
++void            policy(int policy);
++void            priority(int priority);
+ 
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+diff --git a/dot-bochsrc b/dot-bochsrc
+index ba13db7..5341b84 100644
+--- a/dot-bochsrc
++++ b/dot-bochsrc
+@@ -9,8 +9,8 @@
+ # There are two choices of configuration interface: a text mode version
+ # called "textconfig" and a graphical version called "wx".  The text
+ # mode version uses stdin/stdout and is always compiled in.  The graphical
+-# version is only available when you use "--with-wx" on the configure 
+-# command.  If you do not write a config_interface line, Bochs will 
++# version is only available when you use "--with-wx" on the configure
++# command.  If you do not write a config_interface line, Bochs will
+ # choose a default for you.
+ #
+ # NOTE: if you use the "wx" configuration interface, you must also use
+@@ -22,14 +22,14 @@
+ #=======================================================================
+ # DISPLAY_LIBRARY
+ #
+-# The display library is the code that displays the Bochs VGA screen.  Bochs 
+-# has a selection of about 10 different display library implementations for 
+-# different platforms.  If you run configure with multiple --with-* options, 
++# The display library is the code that displays the Bochs VGA screen.  Bochs
++# has a selection of about 10 different display library implementations for
++# different platforms.  If you run configure with multiple --with-* options,
+ # the display_library command lets you choose which one you want to run with.
+ # If you do not write a display_library line, Bochs will choose a default for
+ # you.
+ #
+-# The choices are: 
++# The choices are:
+ #   x              use X windows interface, cross platform
+ #   win32          use native win32 libraries
+ #   carbon         use Carbon library (for MacOS X)
+@@ -94,7 +94,7 @@ romimage: file=$BXSHARE/BIOS-bochs-latest
+ #  Measured IPS value will then be logged into your log file or status bar
+ #  (if supported by the gui).
+ #
+-#  IPS is used to calibrate many time-dependent events within the bochs 
++#  IPS is used to calibrate many time-dependent events within the bochs
+ #  simulation.  For example, changing IPS affects the frequency of VGA
+ #  updates, the duration of time before a key starts to autorepeat, and
+ #  the measurement of BogoMips and other benchmarks.
+@@ -111,7 +111,7 @@ cpu: count=2, ips=10000000
+ 
+ #=======================================================================
+ # MEGS
+-# Set the number of Megabytes of physical memory you want to emulate. 
++# Set the number of Megabytes of physical memory you want to emulate.
+ # The default is 32MB, most OS's won't need more than that.
+ # The maximum amount of memory supported is 2048Mb.
+ #=======================================================================
+@@ -124,11 +124,11 @@ megs: 32
+ 
+ #=======================================================================
+ # OPTROMIMAGE[1-4]:
+-# You may now load up to 4 optional ROM images. Be sure to use a 
++# You may now load up to 4 optional ROM images. Be sure to use a
+ # read-only area, typically between C8000 and EFFFF. These optional
+ # ROM images should not overwrite the rombios (located at
+ # F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+-# Those ROM images will be initialized by the bios if they contain 
++# Those ROM images will be initialized by the bios if they contain
+ # the right signature (0x55AA) and a valid checksum.
+ # It can also be a convenient way to upload some arbitrary code/data
+ # in the simulation, that can be retrieved by the boot loader
+@@ -203,10 +203,10 @@ floppyb: 1_44=b.img, status=inserted
+ # ATA controller for hard disks and cdroms
+ #
+ # ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+-# 
++#
+ # These options enables up to 4 ata channels. For each channel
+ # the two base io addresses and the irq must be specified.
+-# 
++#
+ # ata0 and ata1 are enabled by default with the values shown below
+ #
+ # Examples:
+@@ -224,7 +224,7 @@ ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+ # ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+ #
+ # This defines the type and characteristics of all attached ata devices:
+-#   type=       type of attached device [disk|cdrom] 
++#   type=       type of attached device [disk|cdrom]
+ #   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+ #   mode=       only valid for disks [undoable|growing|volatile]
+ #   path=       path of the image
+@@ -236,16 +236,16 @@ ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+ #   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+ #   model=      string returned by identify device command
+ #   journal=    optional filename of the redolog for undoable and volatile disks
+-#   
++#
+ # Point this at a hard disk image file, cdrom iso file, or physical cdrom
+ # device.  To create a hard disk image, try running bximage.  It will help you
+ # choose the size and then suggest a line that works with it.
+ #
+-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
++# In UNIX it may be possible to use a raw device as a Bochs hard disk,
+ # but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+ #
+ # In windows, the drive letter + colon notation should be used for cdroms.
+-# Depending on versions of windows and drivers, you may only be able to 
++# Depending on versions of windows and drivers, you may only be able to
+ # access the "first" cdrom in the system.  On MacOSX, use path="drive"
+ # to access the physical drive.
+ #
+@@ -274,7 +274,7 @@ ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+ #ata0-slave: type=cdrom, path=D:, status=inserted
+ #ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+ #ata0-slave: type=cdrom, path="drive", status=inserted
+-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
++#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted
+ 
+ #=======================================================================
+ # BOOT:
+@@ -300,9 +300,9 @@ boot: disk
+ #  TO BE COMPLETED (see Greg explanation in feature request #536329)
+ #
+ #  TIME0:
+-#  Specifies the start (boot) time of the virtual machine. Use a time 
+-#  value as returned by the time(2) system call. If no time0 value is 
+-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
++#  Specifies the start (boot) time of the virtual machine. Use a time
++#  value as returned by the time(2) system call. If no time0 value is
++#  set or if time0 equal to 1 (special case) or if time0 equal 'local',
+ #  the simulation will be started at the current local host time.
+ #  If time0 equal to 2 (special case) or if time0 equal 'utc',
+ #  the simulation will be started at the current utc time.
+@@ -318,7 +318,7 @@ boot: disk
+ #   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+ #   clock: sync=none,     time0=1           # Now (localtime)
+ #   clock: sync=none,     time0=utc         # Now (utc/gmt)
+-# 
++#
+ # Default value are sync=none, time0=local
+ #=======================================================================
+ #clock: sync=none, time0=local
+@@ -357,7 +357,7 @@ log: bochsout.txt
+ #   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+ #   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+ #   %d : 5 characters string of the device, between brackets
+-# 
++#
+ # Default : %t%e%d
+ # Examples:
+ #   logprefix: %t-%e-@%i-%d
+@@ -369,7 +369,7 @@ log: bochsout.txt
+ # LOG CONTROLS
+ #
+ # Bochs now has four severity levels for event logging.
+-#   panic: cannot proceed.  If you choose to continue after a panic, 
++#   panic: cannot proceed.  If you choose to continue after a panic,
+ #          don't be surprised if you get strange behavior or crashes.
+ #   error: something went wrong, but it is probably safe to continue the
+ #          simulation.
+@@ -383,7 +383,7 @@ log: bochsout.txt
+ #
+ # If you are experiencing many panics, it can be helpful to change
+ # the panic action to report instead of fatal.  However, be aware
+-# that anything executed after a panic is uncharted territory and can 
++# that anything executed after a panic is uncharted territory and can
+ # cause bochs to become unstable.  The panic is a "graceful exit," so
+ # if you disable it you may get a spectacular disaster instead.
+ #=======================================================================
+@@ -514,7 +514,7 @@ keyboard_serial_delay: 250
+ # characters to the keyboard controller. This leaves time for the
+ # guest os to deal with the flow of characters.  The ideal setting
+ # depends on how your operating system processes characters.  The
+-# default of 100000 usec (.1 seconds) was chosen because it works 
++# default of 100000 usec (.1 seconds) was chosen because it works
+ # consistently in Windows.
+ #
+ # If your OS is losing characters during a paste, increase the paste
+@@ -526,7 +526,7 @@ keyboard_serial_delay: 250
+ keyboard_paste_delay: 100000
+ 
+ #=======================================================================
+-# MOUSE: 
++# MOUSE:
+ # This option prevents Bochs from creating mouse "events" unless a mouse
+ # is  enabled. The hardware emulation itself is not disabled by this.
+ # You can turn the mouse on by setting enabled to 1, or turn it off by
+@@ -563,7 +563,7 @@ private_colormap: enabled=0
+ 
+ #=======================================================================
+ # fullscreen: ONLY IMPLEMENTED ON AMIGA
+-#             Request that Bochs occupy the entire screen instead of a 
++#             Request that Bochs occupy the entire screen instead of a
+ #             window.
+ #
+ # Examples:
+@@ -591,11 +591,11 @@ private_colormap: enabled=0
+ # ethdev: The ethdev value is the name of the network interface on your host
+ # platform.  On UNIX machines, you can get the name by running ifconfig.  On
+ # Windows machines, you must run niclist to get the name of the ethdev.
+-# Niclist source code is in misc/niclist.c and it is included in Windows 
++# Niclist source code is in misc/niclist.c and it is included in Windows
+ # binary releases.
+ #
+-# script: The script value is optional, and is the name of a script that 
+-# is executed after bochs initialize the network interface. You can use 
++# script: The script value is optional, and is the name of a script that
++# is executed after bochs initialize the network interface. You can use
+ # this script to configure this network interface, or enable masquerading.
+ # This is mainly useful for the tun/tap devices that only exist during
+ # Bochs execution. The network interface name is supplied to the script
+@@ -625,10 +625,10 @@ private_colormap: enabled=0
+ 
+ #=======================================================================
+ # KEYBOARD_MAPPING:
+-# This enables a remap of a physical localized keyboard to a 
++# This enables a remap of a physical localized keyboard to a
+ # virtualized us keyboard, as the PC architecture expects.
+ # If enabled, the keymap file must be specified.
+-# 
++#
+ # Examples:
+ #   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+ #=======================================================================
+diff --git a/echo.c b/echo.c
+index 806dee0..eed68a0 100644
+--- a/echo.c
++++ b/echo.c
+@@ -9,5 +9,5 @@ main(int argc, char *argv[])
+ 
+   for(i = 1; i < argc; i++)
+     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+-  exit();
++  exit(0);
+ }
+diff --git a/exec.c b/exec.c
+index b40134f..d07ea7a 100644
+--- a/exec.c
++++ b/exec.c
+@@ -23,7 +23,6 @@ exec(char *path, char **argv)
+ 
+   if((ip = namei(path)) == 0){
+     end_op();
+-    cprintf("exec: fail\n");
+     return -1;
+   }
+   ilock(ip);
+diff --git a/fcntl.h b/fcntl.h
+index d565483..d2a6527 100644
+--- a/fcntl.h
++++ b/fcntl.h
+@@ -2,3 +2,5 @@
+ #define O_WRONLY  0x001
+ #define O_RDWR    0x002
+ #define O_CREATE  0x200
++#define S_IROTH   0x004
++#define S_IWOTH   0x002
+diff --git a/file.c b/file.c
+index 24b32c2..25e3a4e 100644
+--- a/file.c
++++ b/file.c
+@@ -154,4 +154,3 @@ filewrite(struct file *f, char *addr, int n)
+   }
+   panic("filewrite");
+ }
+-
+diff --git a/forktest.c b/forktest.c
+index 8bc984d..4cbcb17 100644
+--- a/forktest.c
++++ b/forktest.c
+@@ -25,24 +25,24 @@ forktest(void)
+     if(pid < 0)
+       break;
+     if(pid == 0)
+-      exit();
++      exit(0);
+   }
+ 
+   if(n == N){
+     printf(1, "fork claimed to work N times!\n", N);
+-    exit();
++    exit(0);
+   }
+ 
+   for(; n > 0; n--){
+-    if(wait() < 0){
++    if(wait(0) < 0){
+       printf(1, "wait stopped early\n");
+-      exit();
++      exit(0);
+     }
+   }
+ 
+-  if(wait() != -1){
++  if(wait(0) != -1){
+     printf(1, "wait got too many\n");
+-    exit();
++    exit(0);
+   }
+ 
+   printf(1, "fork test OK\n");
+@@ -52,5 +52,5 @@ int
+ main(void)
+ {
+   forktest();
+-  exit();
++  exit(0);
+ }
+diff --git a/grep.c b/grep.c
+index adc4835..1aa1081 100644
+--- a/grep.c
++++ b/grep.c
+@@ -43,24 +43,24 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     printf(2, "usage: grep pattern [file ...]\n");
+-    exit();
++    exit(0);
+   }
+   pattern = argv[1];
+ 
+   if(argc <= 2){
+     grep(pattern, 0);
+-    exit();
++    exit(0);
+   }
+ 
+   for(i = 2; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit();
++      exit(0);
+     }
+     grep(pattern, fd);
+     close(fd);
+   }
+-  exit();
++  exit(0);
+ }
+ 
+ // Regexp matcher from Kernighan & Pike,
+diff --git a/init.c b/init.c
+index 046b551..8da3b90 100644
+--- a/init.c
++++ b/init.c
+@@ -24,14 +24,14 @@ main(void)
+     pid = fork();
+     if(pid < 0){
+       printf(1, "init: fork failed\n");
+-      exit();
++      exit(0);
+     }
+     if(pid == 0){
+       exec("sh", argv);
+       printf(1, "init: exec sh failed\n");
+-      exit();
++      exit(0);
+     }
+-    while((wpid=wait()) >= 0 && wpid != pid)
++    while((wpid=wait(0)) >= 0 && wpid != pid)
+       printf(1, "zombie!\n");
+   }
+ }
+diff --git a/initcode.S b/initcode.S
+index 80ac5d8..b8229b8 100644
+--- a/initcode.S
++++ b/initcode.S
+@@ -14,7 +14,7 @@ start:
+   movl $SYS_exec, %eax
+   int $T_SYSCALL
+ 
+-# for(;;) exit();
++# for(;;) exit(0);
+ exit:
+   movl $SYS_exit, %eax
+   int $T_SYSCALL
+diff --git a/kill.c b/kill.c
+index 364f6af..5a2e450 100644
+--- a/kill.c
++++ b/kill.c
+@@ -9,9 +9,9 @@ main(int argc, char **argv)
+ 
+   if(argc < 2){
+     printf(2, "usage: kill pid...\n");
+-    exit();
++    exit(0);
+   }
+   for(i=1; i<argc; i++)
+     kill(atoi(argv[i]));
+-  exit();
++  exit(0);
+ }
+diff --git a/ln.c b/ln.c
+index cf8a64e..14acdc8 100644
+--- a/ln.c
++++ b/ln.c
+@@ -7,9 +7,9 @@ main(int argc, char *argv[])
+ {
+   if(argc != 3){
+     printf(2, "Usage: ln old new\n");
+-    exit();
++    exit(0);
+   }
+   if(link(argv[1], argv[2]) < 0)
+     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+-  exit();
++  exit(0);
+ }
+diff --git a/ls.c b/ls.c
+index 2862913..27742c2 100644
+--- a/ls.c
++++ b/ls.c
+@@ -77,9 +77,9 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     ls(".");
+-    exit();
++    exit(0);
+   }
+   for(i=1; i<argc; i++)
+     ls(argv[i]);
+-  exit();
++  exit(0);
+ }
+diff --git a/main.c b/main.c
+index 6c9e227..588b282 100644
+--- a/main.c
++++ b/main.c
+@@ -33,7 +33,7 @@ main(void)
+   tvinit();        // trap vectors
+   binit();         // buffer cache
+   fileinit();      // file table
+-  ideinit();       // disk 
++  ideinit();       // disk
+   startothers();   // start other processors
+   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+   initSchedDS(); // initialize the data structures for the processes sceduling policies
+@@ -134,4 +134,3 @@ pde_t entrypgdir[NPDENTRIES] = {
+ // Blank page.
+ //PAGEBREAK!
+ // Blank page.
+-
+diff --git a/mkdir.c b/mkdir.c
+index 6e4c954..d101838 100644
+--- a/mkdir.c
++++ b/mkdir.c
+@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     printf(2, "Usage: mkdir files...\n");
+-    exit();
++    exit(0);
+   }
+ 
+   for(i = 1; i < argc; i++){
+@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+     }
+   }
+ 
+-  exit();
++  exit(0);
+ }
+diff --git a/proc.c b/proc.c
+index e68bf1c..ece7d38 100644
+--- a/proc.c
++++ b/proc.c
+@@ -13,22 +13,33 @@ extern RoundRobinQueue rrq;
+ extern RunningProcessesHolder rpholder;
+ 
+ long long getAccumulator(struct proc *p) {
++	return p->accumulator;
+ 	//Implement this function, remove the panic line.
+-	panic("getAccumulator: not implemented\n");
++	//panic("getAccumulator: not implemented\n");
+ }
+-
++enum policy { ROUND_ROBIN, PRIORITY, E_PRIORITY };
++enum policy pol = ROUND_ROBIN;
++int min_priority = 1;
++int max_priority = 10;
++int time_quantum_counter = 0;
++#define DEFAULT_PRIORITY 5
++#define NEW_PROCESS 1 	//true
++#define OLD_PROCESS 0		//false
+ struct {
+   struct spinlock lock;
+   struct proc proc[NPROC];
+ } ptable;
+ 
+ static struct proc *initproc;
++static struct proc *lastProc = 0;
+ 
+ int nextpid = 1;
+ extern void forkret(void);
+ extern void trapret(void);
+ 
+ static void wakeup1(void *chan);
++static void sign_to_q(struct proc *p, int isNew);
++
+ 
+ void
+ pinit(void)
+@@ -48,10 +59,10 @@ struct cpu*
+ mycpu(void)
+ {
+   int apicid, i;
+-  
++
+   if(readeflags()&FL_IF)
+     panic("mycpu called with interrupts enabled\n");
+-  
++
+   apicid = lapicid();
+   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+   // a reverse map, or reserve a register to store &cpus[i].
+@@ -122,6 +133,7 @@ found:
+   memset(p->context, 0, sizeof *p->context);
+   p->context->eip = (uint)forkret;
+ 
++
+   return p;
+ }
+ 
+@@ -134,7 +146,7 @@ userinit(void)
+   extern char _binary_initcode_start[], _binary_initcode_size[];
+ 
+   p = allocproc();
+-  
++
+   initproc = p;
+   if((p->pgdir = setupkvm()) == 0)
+     panic("userinit: out of memory?");
+@@ -159,6 +171,7 @@ userinit(void)
+   acquire(&ptable.lock);
+ 
+   p->state = RUNNABLE;
++	sign_to_q(p, NEW_PROCESS);
+ 
+   release(&ptable.lock);
+ }
+@@ -226,6 +239,8 @@ fork(void)
+ 
+   np->state = RUNNABLE;
+ 
++	sign_to_q(np,NEW_PROCESS);
++
+   release(&ptable.lock);
+ 
+   return pid;
+@@ -233,9 +248,9 @@ fork(void)
+ 
+ // Exit the current process.  Does not return.
+ // An exited process remains in the zombie state
+-// until its parent calls wait() to find out it exited.
++// until its parent calls wait(0) to find out it exited.
+ void
+-exit(void)
++exit(int status)
+ {
+   struct proc *curproc = myproc();
+   struct proc *p;
+@@ -258,8 +273,8 @@ exit(void)
+   curproc->cwd = 0;
+ 
+   acquire(&ptable.lock);
+-
+-  // Parent might be sleeping in wait().
++	curproc->exit_status = status;
++  // Parent might be sleeping in wait(0).
+   wakeup1(curproc->parent);
+ 
+   // Pass abandoned children to init.
+@@ -273,19 +288,19 @@ exit(void)
+ 
+   // Jump into the scheduler, never to return.
+   curproc->state = ZOMBIE;
+-  sched();
++	sched();
+   panic("zombie exit");
+ }
+ 
+ // Wait for a child process to exit and return its pid.
+ // Return -1 if this process has no children.
+ int
+-wait(void)
++wait(int * status)
+ {
+-  struct proc *p;
++	struct proc *p;
+   int havekids, pid;
+   struct proc *curproc = myproc();
+-  
++
+   acquire(&ptable.lock);
+   for(;;){
+     // Scan through table looking for exited children.
+@@ -305,6 +320,11 @@ wait(void)
+         p->name[0] = 0;
+         p->killed = 0;
+         p->state = UNUSED;
++				// discard the status if it's null
++				if(p->exit_status != null){
++					*status = p->exit_status;
++
++				}
+         release(&ptable.lock);
+         return pid;
+       }
+@@ -318,9 +338,198 @@ wait(void)
+ 
+     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+     sleep(curproc, &ptable.lock);  //DOC: wait-sleep
++
+   }
+ }
+ 
++// Detach : detach the process with pid from current paret to init
++int detach(int pid){
++	struct proc *p;
++	struct proc *curproc = myproc();
++	acquire(&ptable.lock);
++	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++		if (pid!= p->pid || curproc!= p->parent)
++			continue;
++
++		p->parent = 0;
++		release(&ptable.lock);
++		return 0;
++
++	}
++	release(&ptable.lock);
++	cprintf("Detach failed, no child proccess with pid %d \n", pid);
++	return -1;
++}
++void priority(int priority){
++
++	if(priority >= min_priority && priority <= max_priority){
++		acquire(&ptable.lock);
++	 	myproc()->priority = priority;
++		release(&ptable.lock);
++ 	}
++ 	else panic("Priorety is not in allowed range");
++
++}
++
++void updateMinAccumulator(struct proc* p){
++
++	long long acc_pq, acc_rq;
++
++    int pqSuccess = pq.getMinAccumulator(&acc_pq);
++    int rqSuccess = rpholder.getMinAccumulator(&acc_rq);
++
++    if (pqSuccess == 1 && rqSuccess == 1) {
++        p->accumulator = acc_pq < acc_rq ? acc_pq : acc_rq;
++    } else if (pqSuccess == 1) {
++        p->accumulator = acc_pq;
++		}
++    // } else if (rqSuccess == 1) {
++    //     p->accumulator = acc_rq;
++    // }
++		else {
++			p->accumulator = 0;
++		}
++}
++
++void sign_to_q(struct proc *p,int isNew){
++
++
++	if(!isNew){
++		if(pol != ROUND_ROBIN){
++			p->accumulator = p->accumulator + p->priority;
++		}
++	}
++	else{
++		p->priority = DEFAULT_PRIORITY;
++		if(pol != ROUND_ROBIN){
++			updateMinAccumulator(p);
++		}
++
++	}
++
++	if(p->state == RUNNABLE){
++	switch (pol){
++	case ROUND_ROBIN:
++		rrq.enqueue(p);
++	break;
++	case PRIORITY:
++		pq.put(p);
++	break;
++	case E_PRIORITY:
++		pq.put(p);
++		break;
++	default:
++		rrq.enqueue(p);
++	}
++}
++}
++
++void policy(int policy) {
++	//cprintf("old:%d new: %d", pol,policy);
++	 struct proc *pr;
++	int oldPolicy = pol;
++  pol = policy;
++	acquire(&ptable.lock);
++	switch (oldPolicy) {
++		case ROUND_ROBIN:
++			switch (pol){
++			case ROUND_ROBIN:
++				//cprintf("ROUND_ROBIN");
++				break;
++			case PRIORITY:
++				//cprintf("THIS IS PRIORITY");
++				if(!rrq.switchToPriorityQueuePolicy())
++					cprintf("RRQ is empty");
++			break;
++			case E_PRIORITY:
++			//	cprintf("E_PRIORITY");
++				if(!rrq.switchToPriorityQueuePolicy())
++					cprintf("RRQ is empty");
++				min_priority = 0;
++				//TODO
++			break;
++		}break;
++		case PRIORITY:
++			switch (pol){
++			case ROUND_ROBIN:
++	//			cprintf("ROUND_ROBIN");
++			for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
++				pr->accumulator = 0;
++			}
++				pq.switchToRoundRobinPolicy();
++			break;
++			case PRIORITY:
++	//		cprintf("THIS IS PRIORITY");
++			break;
++			case E_PRIORITY:
++	//		cprintf("E_PRIORITY");
++				min_priority = 0;
++			break;
++			}
++		break;
++		case E_PRIORITY:
++			switch (pol){
++				case ROUND_ROBIN:
++					//cprintf("ROUND_ROBIN");
++					for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
++						pr->accumulator = 0;
++					}
++					pq.switchToRoundRobinPolicy();
++					min_priority = 1;
++				break;
++				case PRIORITY:
++			//		cprintf("THIS IS PRIORITY");
++					for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
++			    	pr->priority = pr->priority == 0 ? 1 : pr->priority;
++			    }
++					min_priority = 1;
++				break;
++				case E_PRIORITY:
++	//				cprintf("E_PRIORITY");
++				break;
++			}
++		break;
++	}
++	 release(&ptable.lock);
++}
++
++struct proc* getProc() {
++	struct proc * p;
++	switch (pol){
++	case ROUND_ROBIN:
++		if(!rrq.isEmpty()){
++			return rrq.dequeue();
++		}
++	break;
++	case PRIORITY:
++		if(!pq.isEmpty()){
++			return pq.extractMin();
++		}
++	break;
++	case E_PRIORITY:
++		if(!pq.isEmpty()){
++			p = pq.extractMin();
++			if(lastProc == p){
++				if(time_quantum_counter % 100 == 0){
++					struct proc * otherProc = pq.extractMin();
++					pq.put(p);
++					return otherProc;
++				}
++				else{
++					time_quantum_counter++;
++					return p;
++				}
++			}
++			else{
++				time_quantum_counter = 0;
++				return p;
++			}
++		}
++	break;
++	}
++		return null;
++}
++
+ //PAGEBREAK: 42
+ // Per-CPU process scheduler.
+ // Each CPU calls scheduler() after setting itself up.
+@@ -329,13 +538,13 @@ wait(void)
+ //  - swtch to start running that process
+ //  - eventually that process transfers control
+ //      via swtch back to the scheduler.
++//ORIGINAL SKEDULAR
+ void
+-scheduler(void)
+-{
++a_scheduler(void){
+   struct proc *p;
+   struct cpu *c = mycpu();
+   c->proc = 0;
+-  
++
+   for(;;){
+     // Enable interrupts on this processor.
+     sti();
+@@ -349,10 +558,12 @@ scheduler(void)
+       // Switch to chosen process.  It is the process's job
+       // to release ptable.lock and then reacquire it
+       // before jumping back to us.
+-      c->proc = p;
++			rrq.enqueue(p);
++      c->proc = getProc();
++
+       switchuvm(p);
+       p->state = RUNNING;
+-
++			rpholder.add(p);
+       swtch(&(c->scheduler), p->context);
+       switchkvm();
+ 
+@@ -364,7 +575,53 @@ scheduler(void)
+ 
+   }
+ }
++//PAGEBREAK: 42
++// Per-CPU process scheduler.
++// Each CPU calls scheduler() after setting itself up.
++// Scheduler never returns.  It loops, doing:
++//  - choose a process to run
++//  - swtch to start running that process
++//  - eventually that process transfers control
++//      via swtch back to the scheduler.
++void
++scheduler(void){
++  struct proc *p=0;
++  struct cpu *c = mycpu();
++  c->proc = 0;
++
++  for(;;){
++
++    // Enable interrupts on this processor.
++    sti();
++
++    // Loop over process table looking for process to run.
++    acquire(&ptable.lock);
++		p = getProc();
++		lastProc = p;
++    if(p != 0 && p->state == RUNNABLE) {
++
++      // Switch to chosen process.  It is the process's job
++      // to release ptable.lock and then reacquire it
++      // before jumping back to us.
+ 
++      c->proc = p;
++
++      switchuvm(p);
++      p->state = RUNNING;
++			rpholder.add(p);
++      swtch(&(c->scheduler), p->context);
++      switchkvm();
++			c->proc = 0;
++			rpholder.remove(p);
++			sign_to_q(p,OLD_PROCESS);
++      // Process is done running for now.
++      // It should have changed its p->state before coming back.
++
++    }
++    release(&ptable.lock);
++
++  }
++}
+ // Enter scheduler.  Must hold only ptable.lock
+ // and have changed proc->state. Saves and restores
+ // intena because intena is a property of this
+@@ -396,7 +653,8 @@ void
+ yield(void)
+ {
+   acquire(&ptable.lock);  //DOC: yieldlock
+-  myproc()->state = RUNNABLE;
++	struct proc * p = myproc();
++  p->state = RUNNABLE;
+   sched();
+   release(&ptable.lock);
+ }
+@@ -428,7 +686,7 @@ void
+ sleep(void *chan, struct spinlock *lk)
+ {
+   struct proc *p = myproc();
+-  
++
+   if(p == 0)
+     panic("sleep");
+ 
+@@ -448,8 +706,7 @@ sleep(void *chan, struct spinlock *lk)
+   // Go to sleep.
+   p->chan = chan;
+   p->state = SLEEPING;
+-
+-  sched();
++	sched();
+ 
+   // Tidy up.
+   p->chan = 0;
+@@ -470,8 +727,10 @@ wakeup1(void *chan)
+   struct proc *p;
+ 
+   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+-    if(p->state == SLEEPING && p->chan == chan)
++    if(p->state == SLEEPING && p->chan == chan){
+       p->state = RUNNABLE;
++			sign_to_q(p,OLD_PROCESS);
++		}
+ }
+ 
+ // Wake up all processes sleeping on chan.
+@@ -496,8 +755,11 @@ kill(int pid)
+     if(p->pid == pid){
+       p->killed = 1;
+       // Wake process from sleep if necessary.
+-      if(p->state == SLEEPING)
++      if(p->state == SLEEPING){
+         p->state = RUNNABLE;
++				updateMinAccumulator(p);
++
++			}
+       release(&ptable.lock);
+       return 0;
+     }
+diff --git a/proc.h b/proc.h
+index 6ad690e..6b5a591 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,8 +49,11 @@ struct proc {
+   void *chan;                    // If non-zero, sleeping on chan
+   int killed;                    // If non-zero, have been killed
+   struct file *ofile[NOFILE];    // Open files
+-  struct inode *cwd;             // Current directory  
++  struct inode *cwd;             // Current directory
+   char name[16];                 // Process name (debugging)
++  int exit_status;               // procs exit code assigned to exit call
++  long long accumulator;         //accumulator of priority
++  int priority ;                 //process priority
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff --git a/rm.c b/rm.c
+index 4fd33c8..83c5f36 100644
+--- a/rm.c
++++ b/rm.c
+@@ -9,7 +9,7 @@ main(int argc, char *argv[])
+ 
+   if(argc < 2){
+     printf(2, "Usage: rm files...\n");
+-    exit();
++    exit(0);
+   }
+ 
+   for(i = 1; i < argc; i++){
+@@ -19,5 +19,5 @@ main(int argc, char *argv[])
+     }
+   }
+ 
+-  exit();
++  exit(0);
+ }
+diff --git a/sh.c b/sh.c
+index 054bab9..c2ef7aa 100644
+--- a/sh.c
++++ b/sh.c
+@@ -3,6 +3,7 @@
+ #include "types.h"
+ #include "user.h"
+ #include "fcntl.h"
++#include "stat.h"
+ 
+ // Parsed command representation
+ #define EXEC  1
+@@ -63,9 +64,16 @@ runcmd(struct cmd *cmd)
+   struct listcmd *lcmd;
+   struct pipecmd *pcmd;
+   struct redircmd *rcmd;
++  int fd;
++  char c[1];
++  char s[512];
++  int stringLocation = 0;
++  char * myCmd;
++  int cmdName = 0;
++
+ 
+   if(cmd == 0)
+-    exit();
++    exit(0);
+ 
+   switch(cmd->type){
+   default:
+@@ -74,17 +82,48 @@ runcmd(struct cmd *cmd)
+   case EXEC:
+     ecmd = (struct execcmd*)cmd;
+     if(ecmd->argv[0] == 0)
+-      exit();
++    exit(0);
++    //Try to exec original command
+     exec(ecmd->argv[0], ecmd->argv);
++    printf(2,"returned from exec\n" );
++    //Returned from exec -> Couldn't find cmd in current dir -> try to find with path file
++    fd = open("/path",O_RDONLY);
++    myCmd = ecmd->argv[0];
++    if (myCmd[0] != '/'){
++      while (read(fd,c,1) != 0){
++        if (c[0]!=':'){
++          s[stringLocation] = c[0];
++          stringLocation++;
++        }
++        else{
++          while(myCmd[cmdName] != 0){
++            s[stringLocation] = myCmd[cmdName];
++            stringLocation++;
++            cmdName++;
++          }
++          s[stringLocation] = 0;
++          stringLocation = 0;
++          cmdName = 0;
++          // DEBUG, DELETE LATER:printf(2,"cmd is:%s\n",s);
++          exec(s, ecmd->argv);
++
++          }
++        }
++        printf(2, "exec %s failed\n", ecmd->argv[0]);
++  }
++  else{
+     printf(2, "exec %s failed\n", ecmd->argv[0]);
++  }
++  close(fd);
+     break;
+ 
++
+   case REDIR:
+     rcmd = (struct redircmd*)cmd;
+     close(rcmd->fd);
+     if(open(rcmd->file, rcmd->mode) < 0){
+       printf(2, "open %s failed\n", rcmd->file);
+-      exit();
++      exit(0);
+     }
+     runcmd(rcmd->cmd);
+     break;
+@@ -93,7 +132,7 @@ runcmd(struct cmd *cmd)
+     lcmd = (struct listcmd*)cmd;
+     if(fork1() == 0)
+       runcmd(lcmd->left);
+-    wait();
++    wait(0);
+     runcmd(lcmd->right);
+     break;
+ 
+@@ -117,8 +156,8 @@ runcmd(struct cmd *cmd)
+     }
+     close(p[0]);
+     close(p[1]);
+-    wait();
+-    wait();
++    wait(0);
++    wait(0);
+     break;
+ 
+   case BACK:
+@@ -127,7 +166,7 @@ runcmd(struct cmd *cmd)
+       runcmd(bcmd->cmd);
+     break;
+   }
+-  exit();
++  exit(0);
+ }
+ 
+ int
+@@ -144,8 +183,12 @@ getcmd(char *buf, int nbuf)
+ int
+ main(void)
+ {
++//TODO:delete LATER
++
++
+   static char buf[100];
+   int fd;
++  int fdpath;
+ 
+   // Ensure that three file descriptors are open.
+   while((fd = open("console", O_RDWR)) >= 0){
+@@ -155,6 +198,28 @@ main(void)
+     }
+   }
+ 
++
++  //check if path file exists ' create it if not.'
++  int init_path_size=2;
++  char *  init_path= "/:";
++  if(open("path",O_RDONLY ) < 0 ){
++    if((fdpath = open("path", O_CREATE| O_RDWR ))>=0 ){
++      if(write(fdpath,init_path,init_path_size)!=init_path_size){
++        panic("could not write to file");
++      }
++
++    }
++    else {
++      panic("could not create file path");
++    }
++
++  }
++  else{
++    printf(2,"file path exists\n", 18);
++  }
++
++
++
+   // Read and run input commands.
+   while(getcmd(buf, sizeof(buf)) >= 0){
+     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+@@ -166,16 +231,16 @@ main(void)
+     }
+     if(fork1() == 0)
+       runcmd(parsecmd(buf));
+-    wait();
++    wait(0);
+   }
+-  exit();
++  exit(0);
+ }
+ 
+ void
+ panic(char *s)
+ {
+   printf(2, "%s\n", s);
+-  exit();
++  exit(0);
+ }
+ 
+ int
+diff --git a/stressfs.c b/stressfs.c
+index c0a4743..06a07ca 100644
+--- a/stressfs.c
++++ b/stressfs.c
+@@ -43,7 +43,7 @@ main(int argc, char *argv[])
+     read(fd, data, sizeof(data));
+   close(fd);
+ 
+-  wait();
++  wait(0);
+ 
+-  exit();
++  exit(0);
+ }
+diff --git a/syscall.c b/syscall.c
+index ee85261..30b4ead 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -25,6 +25,17 @@ fetchint(uint addr, int *ip)
+   return 0;
+ }
+ 
++// Fetch the int ptr at addr from the current process.
++// int
++// fetchintptr(uint addr, int **ip)
++// {
++//   struct proc *curproc = myproc();
++//
++//   if(addr >= curproc->sz || addr+4 > curproc->sz)
++//     return -1;
++//   *ip = addr;
++//   return 0;
++// }
+ // Fetch the nul-terminated string at addr from the current process.
+ // Doesn't actually copy the string - just sets *pp to point at it.
+ // Returns length of string, not including nul.
+@@ -52,6 +63,7 @@ argint(int n, int *ip)
+   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+ }
+ 
++
+ // Fetch the nth word-sized system call argument as a pointer
+ // to a block of memory of size bytes.  Check that the pointer
+ // lies within the process address space.
+@@ -60,7 +72,7 @@ argptr(int n, char **pp, int size)
+ {
+   int i;
+   struct proc *curproc = myproc();
+- 
++
+   if(argint(n, &i) < 0)
+     return -1;
+   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+@@ -103,6 +115,9 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_detach(void);
++extern int sys_policy(void);
++extern int sys_priority(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +141,10 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_detach]  sys_detach,
++[SYS_policy]  sys_policy,
++[SYS_priority] sys_priority,
++
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index bc5f356..a302c63 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,6 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_detach 22
++#define SYS_policy 23
++#define SYS_priority 24
+diff --git a/sysproc.c b/sysproc.c
+index 0686d29..f4934b7 100644
+--- a/sysproc.c
++++ b/sysproc.c
+@@ -16,14 +16,22 @@ sys_fork(void)
+ int
+ sys_exit(void)
+ {
+-  exit();
++  int status;
++
++  if(argint(0,&status)<0)
++    return -1;
++  exit(status);
+   return 0;  // not reached
+ }
+ 
+ int
+ sys_wait(void)
+ {
+-  return wait();
++  int * status;
++  if(argint(0,(int *)(&status))<0)
++    return -1;
++
++  return wait(status);
+ }
+ 
+ int
+@@ -36,6 +44,39 @@ sys_kill(void)
+   return kill(pid);
+ }
+ 
++int
++sys_detach(void)
++{
++  int pid;
++  if(argint(0, &pid) < 0)
++    return -1;
++  return detach(pid);
++}
++
++int
++sys_policy(void)
++{
++  int poli;
++  if(argint(0, &poli)<0){
++    return -1;
++  }
++  if(poli != 1 && poli != 2 && poli != 3)
++    return -1;
++  poli--;
++  policy(poli);
++  return 0;
++}
++int
++sys_priority(void)
++{
++  int priority;
++  if(argint(0, &priority)<0){
++    return -1;
++  }
++  policy(priority);
++  return 0;
++}
++
+ int
+ sys_getpid(void)
+ {
+diff --git a/test.c b/test.c
+new file mode 100644
+index 0000000..d4df3dc
+--- /dev/null
++++ b/test.c
+@@ -0,0 +1,290 @@
++//
++// Created by nadav on 3/13/19.
++//
++#include "types.h"
++#include "user.h"
++#include "fcntl.h"
++
++#define ROUND_ROBIN 1
++#define PRIORITY 2
++#define EXTENED_PRIORITY 3
++
++struct perf {
++    int ctime;                     // Creation time
++    int ttime;                     // Termination time
++    int stime;                     // The total time spent in the SLEEPING state
++    int retime;                    // The total time spent in the RUNNABLE state
++    int rutime;                    // The total time spent in the RUNNING state
++};
++
++
++typedef boolean (test_runner)();
++
++void run_test(test_runner *test, char *name) {
++    printf(1, "========== Test - %s: Begin ==========\n", name);
++    boolean result = (*test)();
++    if (result) {
++        printf(1, "========== Test - %s: Passed ==========\n", name);
++    } else {
++        printf(1, "========== Test - %s: Failed ==========\n", name);
++    }
++}
++
++boolean assert_equals(int expected, int actual, char *msg) {
++    if (expected != actual) {
++        printf(2, "Assert %s failed: expected %d but got %d\n", msg, expected, actual);
++        return false;
++    } else return true;
++}
++
++
++void print_perf(struct perf *performance) {
++    printf(1, "pref:\n");
++    printf(1, "\tctime: %d\n", performance->ctime);
++    printf(1, "\tttime: %d\n", performance->ttime);
++    printf(1, "\tstime: %d\n", performance->stime);
++    printf(1, "\tretime: %d\n", performance->retime);
++    printf(1, "\trutime: %d\n", performance->rutime);
++    printf(1, "\n\tTurnaround time: %d\n", (performance->ttime - performance->ctime));
++}
++
++int fact(int n) {
++    if (!n)
++        return 0;
++    return n * fact(n - 1);
++}
++
++unsigned long long fact2(unsigned long long n, unsigned long long k) {
++    start:
++    if (n == 1) {
++        return k;
++    } else {
++        --n;
++        k = k * n;
++        goto start;
++    }
++
++
++}
++
++int fib(int n) {
++    if (!n)
++        return 1;
++    return fib(n - 1) + fib(n - 2);
++}
++
++
++boolean test_exit_wait() {
++    int status;
++    boolean result = true;
++    int pid;
++    for (int i = 0; i < 20; ++i) {
++        pid = fork();
++        if (pid > 0) {
++            wait(&status);
++            result = result && assert_equals(i, status, "exit&wait");
++            status = -1;
++        } else {
++            sleep(3);
++            exit(i);
++        }
++    }
++    return result;
++}
++
++boolean test_detach() {
++    int status1;
++    int status2;
++    int status3;
++    int pid;
++    boolean result1;
++    boolean result2;
++    boolean result3;
++
++    pid = fork();
++    if (pid > 0) {
++        status1 = detach(pid);
++        result1 = assert_equals(0, status1, "detach - status1");
++
++        status2 = detach(pid);
++        result2 = assert_equals(-1, status2, "detach - status2");
++
++        status3 = detach(-10);
++        result3 = assert_equals(-1, status3, "detach - status3");
++
++        return result1 && result2 && result3;
++    } else {
++        sleep(100);
++        exit(0);
++    }
++}
++
++boolean test_policy_helper(int *priority_mod, int policy) {
++    int nProcs = 100;
++    int pid, status;
++    boolean result = true;
++    for (int i = 0; i < nProcs; ++i) {
++        pid = fork();
++        if (pid < 0) {
++            break;
++        } else if (pid == 0) {
++            if (priority_mod) {
++                if ((i % *(priority_mod)) == 0 && policy == PRIORITY) {
++                    priority(1);
++                } else {
++                    priority(i % (*priority_mod));
++                }
++            }
++            sleep(10);
++            exit(0);
++        }
++    }
++    for (int j = 0; j < nProcs; ++j) {
++        wait(&status);
++        result = result && assert_equals(0, status, "round robin");
++    }
++    return result;
++
++}
++
++boolean test_round_robin_policy() {
++    return test_policy_helper(null, null);
++
++}
++
++boolean test_priority_policy() {
++    int priority_mod = 10;
++    policy(PRIORITY);
++    boolean result = test_policy_helper(&priority_mod, PRIORITY);
++    policy(ROUND_ROBIN);
++    return result;
++}
++
++boolean test_extended_priority_policy() {
++    int priority_mod = 10;
++    policy(EXTENED_PRIORITY);
++    boolean result = test_policy_helper(&priority_mod, EXTENED_PRIORITY);
++    policy(ROUND_ROBIN);
++    return result;
++}
++
++// boolean test_performance_helper(int *npriority) {
++//     int pid1;
++//     struct perf perf2;
++//     pid1 = fork();
++//     if (pid1 > 0) {
++// //        int status1;
++//     //    wait_stat(&status1, &perf2);
++//         print_perf(&perf2);
++//     } else {
++//         for (int a = 0; a < 100; ++a) {
++//             int pid;
++//             struct perf perf1;
++//
++//             pid = fork();
++//             // the child pid is pid
++//             if (pid > 0) {
++//                 int status;
++//                 sleep(5);
++//           //      wait_stat(&status, &perf1);
++//             } else {
++//                 if (npriority)
++//                     priority(*npriority);
++//                 int sum = 0;
++//                 for (int i = 0; i < 100000000; ++i) {
++//                     for (int j = 0; j < 100000000; ++j) {
++//                         ++sum;
++//                     }
++//                 }
++//                 sleep(5);
++//                 exit(0);
++//             }
++//         }
++//         exit(0);
++//     }
++//     return true;
++// }
++
++
++boolean test_starvation_helper(int npolicy, int npriority) {
++    boolean result = true;
++    policy(npolicy);
++    int nProcs = 10;
++    int pid_arr[nProcs];
++    int pid;
++    memset(&pid_arr, 0, nProcs * sizeof(int));
++    for (int i = 0; i < nProcs; ++i) {
++        pid = fork();
++        if (pid < 0) {
++            break;
++        } else if (pid == 0) {
++            sleep(5);
++            priority(npriority);
++            for (;;) {};
++        } else {
++            pid_arr[i] = pid;
++        }
++    }
++    sleep(100);
++    for (int j = 0; j < nProcs; ++j) {
++        if (pid_arr[j] != 0) {
++            result = result && assert_equals(0, kill(pid_arr[j]), "failed to kill child (yes it does sound horrible)");
++            wait(null);
++        }
++    }
++    policy(ROUND_ROBIN);
++    return result;
++}
++
++/**
++ * test the growth of accumulator
++ */
++boolean test_accumulator() {
++    return test_starvation_helper(PRIORITY, 2);
++}
++
++/** I hope this does test the case of
++   starvation in extended priority
++   (where the priority is 0)
++*/
++boolean test_starvation() {
++    return test_starvation_helper(EXTENED_PRIORITY, 0);
++}
++
++
++// boolean test_performance_round_robin() {
++//     return test_performance_helper(null);
++// }
++//
++// boolean test_performance_priority() {
++//     policy(PRIORITY);
++//     int npriority = 2;
++//     boolean result = test_performance_helper(&npriority);
++//     policy(ROUND_ROBIN);
++//     return result;
++//
++// }
++//
++// boolean test_performance_extended_priority() {
++//     policy(EXTENED_PRIORITY);
++//     int npriority = 0;
++//     boolean result = test_performance_helper(&npriority);
++//     policy(ROUND_ROBIN);
++//     return result;
++//
++// }
++
++
++int main(void) {
++    run_test(&test_exit_wait, "exit&wait");
++    run_test(&test_detach, "detach");
++    run_test(&test_round_robin_policy, "round robin policy");
++    run_test(&test_priority_policy, "priority policy");
++    //run_test(&test_extended_priority_policy, "extended priority policy");
++  //  run_test(&test_accumulator, "accumulator");
++    run_test(&test_starvation, "starvation");
++  //  run_test(&test_performance_round_robin, "performance round robin");
++  //  run_test(&test_performance_priority, "performance priority");
++  //  run_test(&test_performance_extended_priority, "performance extended priority");
++    exit(0);
++}
+diff --git a/tests.c b/tests.c
+new file mode 100644
+index 0000000..5d235ae
+--- /dev/null
++++ b/tests.c
+@@ -0,0 +1,177 @@
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++
++
++
++
++int success=0, fail=0,ans=-2;
++
++void test_exit_wait_success(){
++
++    int pid = fork();
++    if(pid!=0){
++      wait(&ans);
++    }
++    else {
++      exit(1);}
++}
++void test_exit_wait_fail(){
++
++  int pid = fork();
++  if(pid>0){
++    wait(&ans);
++  }
++  else exit(-1);
++}
++void test_detach_success(){
++  int pid;
++  pid = fork();
++  if(pid > 0) {
++   ans = detach(pid);
++
++} else
++  {
++    sleep(10);
++    exit(0);
++  }
++}
++
++void test_detach_fail(){
++  int pid;
++  pid = fork();
++  if(pid > 0) {
++    wait(0);
++   ans = detach(pid+9); // status = -1
++
++  }
++  else
++  {
++    exit(0);
++  }
++
++}
++
++void test_detach_wrong_parent(){
++  int pid;
++  pid = fork();
++  if(pid == 0) {
++      ans = detach(pid); // status = -1
++      exit(0);
++  }
++  else wait(0);
++}
++
++void round_robin_sanity(){
++  int pid,pid2;
++  pid = fork();
++  if(pid>0){
++    pid2=fork();
++    if(pid2==0){
++      int i;sleep(3);
++      for(i=0;i<3;i++){
++
++        write(2,"Going to sleep son 2\n",21);
++        sleep(1);
++        write(2,"woke up son 2\n",16);
++      }
++      write(2,"son 2 exiting\n",16);
++      sleep(1);
++        exit(0);
++    }
++    else {  wait(0);wait(0);}
++  }
++  else{
++    int i;
++    for(i=0;i<3;i++){
++      write(2,"Going to sleep son 1\n",21);
++      sleep(3);
++      write(2,"woke up son 1\n",16);
++    }
++    write(2,"son 1 exiting\n",16);
++    exit(0);
++  }
++}
++void test_3sons(int pol){
++  policy(pol);
++  int pid,pid2,pid3;
++  pid = fork();
++  if(pid>0){
++    sleep(1);
++    pid2=fork();
++    if(pid2>0){
++      sleep(1);
++      pid3=fork();
++      if(pid3 == 0){
++        //sleep(1);
++        int i;
++        for(i=0;i<3;i++){
++          write(2,"Going to sleep son 3\n",21);
++          sleep(1);
++          write(2,"woke up son 3\n",15);
++        }
++        write(2,"son 3 exiting\n",15);
++        sleep(1);
++          exit(0);
++      }
++      else {wait(0);wait(0);wait(0);}
++    }
++    else{
++      sleep(2);
++      int i;
++      for(i=0;i<3;i++){
++        write(2,"Going to sleep son 2\n",21);
++        sleep(1);
++        write(2,"woke up son 2\n",15);
++      }
++      write(2,"son 2 exiting\n",15);
++      sleep(1);
++        exit(0);
++    }
++  }
++  else{
++    sleep(3);
++    int i;
++    for(i=0;i<3;i++){
++      write(2,"Going to sleep son 1\n",21);
++      sleep(1);
++      write(2,"woke up son 1\n",15);
++    }
++    write(2,"son 1 exiting\n",15);
++    exit(0);
++  }
++}
++
++void make_test(void (*f)(void) , int expected ,char * fail_msg){
++
++  (*f)();
++  if(ans == expected)
++    success++;
++  else {
++    fail++;
++    printf(2,"%s\n",fail_msg);
++  }
++
++}
++void some(){
++  printf(2,"start some\n" );
++  policy(2);
++}
++int main(void){
++  //round_robin_sanity();
++
++//  some();
++  for (int i=0;i<100;i++){
++  test_3sons(1);
++}
++
++  //make_test(test_exit_wait_success, 1, "test_exit_wait_success failed\n");
++  //make_test(test_exit_wait_fail, -1 , "test_exit_wait_fail failed\n");
++  //make_test(test_detach_success,0,"test_detach_success failed\n");
++  //make_test(test_detach_fail,-1,"test_detach_fail failed\n");
++  //make_test(test_detach_wrong_parent,-1,"test_detach_wrong_parent failed\n");
++  printf(2,"num of success:%d num of failures: %d\n",success,fail );
++
++  exit(0);
++
++}
+diff --git a/trap.c b/trap.c
+index 41c66eb..dbc9f6f 100644
+--- a/trap.c
++++ b/trap.c
+@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
+ {
+   if(tf->trapno == T_SYSCALL){
+     if(myproc()->killed)
+-      exit();
++      exit(0);
+     myproc()->tf = tf;
+     syscall();
+     if(myproc()->killed)
+-      exit();
++      exit(0);
+     return;
+   }
+ 
+@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
+   // (If it is still executing in the kernel, let it keep running
+   // until it gets to the regular system call return.)
+   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit();
++    exit(0);
+ 
+   // Force process to give up CPU on clock tick.
+   // If interrupts were on while locks held, would need to check nlock.
+@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
+ 
+   // Check if the process has been killed since we yielded
+   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+-    exit();
++    exit(0);
+ }
+diff --git a/user.h b/user.h
+index 4f99c52..96b1ca6 100644
+--- a/user.h
++++ b/user.h
+@@ -3,8 +3,8 @@ struct rtcdate;
+ 
+ // system calls
+ int fork(void);
+-int exit(void) __attribute__((noreturn));
+-int wait(void);
++int exit(int) __attribute__((noreturn));
++int wait(int * status);
+ int pipe(int*);
+ int write(int, const void*, int);
+ int read(int, void*, int);
+@@ -23,6 +23,9 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int detach(int pid);
++void policy(int policy);
++void priority(int priority);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 8bfd8a1..f6edb3a 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,6 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(detach)
++SYSCALL(policy)
++SYSCALL(priority)
+diff --git a/wc.c b/wc.c
+index d6a54df..1d4f708 100644
+--- a/wc.c
++++ b/wc.c
+@@ -27,7 +27,7 @@ wc(int fd, char *name)
+   }
+   if(n < 0){
+     printf(1, "wc: read error\n");
+-    exit();
++    exit(0);
+   }
+   printf(1, "%d %d %d %s\n", l, w, c, name);
+ }
+@@ -39,16 +39,16 @@ main(int argc, char *argv[])
+ 
+   if(argc <= 1){
+     wc(0, "");
+-    exit();
++    exit(0);
+   }
+ 
+   for(i = 1; i < argc; i++){
+     if((fd = open(argv[i], 0)) < 0){
+       printf(1, "wc: cannot open %s\n", argv[i]);
+-      exit();
++      exit(0);
+     }
+     wc(fd, argv[i]);
+     close(fd);
+   }
+-  exit();
++  exit(0);
+ }
+diff --git a/zombie.c b/zombie.c
+index ee817da..c96b92d 100644
+--- a/zombie.c
++++ b/zombie.c
+@@ -10,5 +10,5 @@ main(void)
+ {
+   if(fork() > 0)
+     sleep(5);  // Let child exit before parent.
+-  exit();
++  exit(0);
+ }
diff --git a/Makefile b/Makefile
index 920b6a3..197bb99 100644
--- a/Makefile
+++ b/Makefile
@@ -33,7 +33,7 @@ OBJS = \
 # TOOLPREFIX = i386-elf-
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -141,7 +141,7 @@ kernel: $(OBJS) entry.o entryother initcode kernel.ld
 	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
 
 ass1ds.o:
-	$(GPP) $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
 
 # kernelmemfs is a copy of kernel that maintains the
 # disk image in memory instead of writing to a disk.
@@ -198,13 +198,16 @@ UPROGS=\
 	_stressfs\
 	_wc\
 	_zombie\
+	_policy\
+	_tests\
+	_test\
 
-fs.img: mkfs README $(UPROGS)
-	./mkfs fs.img README $(UPROGS)
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
diff --git a/Operating System Test ASS1.tar.gz b/Operating System Test ASS1.tar.gz
new file mode 100644
index 0000000..cb4c58d
Binary files /dev/null and b/Operating System Test ASS1.tar.gz differ
diff --git a/Project_Test/.vscode/settings.json b/Project_Test/.vscode/settings.json
new file mode 100644
index 0000000..90136cc
--- /dev/null
+++ b/Project_Test/.vscode/settings.json
@@ -0,0 +1,47 @@
+{
+    "files.associations": {
+        "iostream": "cpp",
+        "cctype": "cpp",
+        "cmath": "cpp",
+        "cstdarg": "cpp",
+        "cstddef": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "array": "cpp",
+        "atomic": "cpp",
+        "strstream": "cpp",
+        "*.tcc": "cpp",
+        "chrono": "cpp",
+        "clocale": "cpp",
+        "complex": "cpp",
+        "cstdint": "cpp",
+        "cwctype": "cpp",
+        "unordered_map": "cpp",
+        "vector": "cpp",
+        "exception": "cpp",
+        "fstream": "cpp",
+        "functional": "cpp",
+        "initializer_list": "cpp",
+        "iosfwd": "cpp",
+        "istream": "cpp",
+        "limits": "cpp",
+        "memory": "cpp",
+        "new": "cpp",
+        "ostream": "cpp",
+        "ratio": "cpp",
+        "sstream": "cpp",
+        "stdexcept": "cpp",
+        "streambuf": "cpp",
+        "system_error": "cpp",
+        "thread": "cpp",
+        "cinttypes": "cpp",
+        "type_traits": "cpp",
+        "tuple": "cpp",
+        "typeindex": "cpp",
+        "typeinfo": "cpp",
+        "utility": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/Project_Test/Tests/test_0/Makefile b/Project_Test/Tests/test_0/Makefile
new file mode 100644
index 0000000..5c1fe82
--- /dev/null
+++ b/Project_Test/Tests/test_0/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _usertests\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_usertests: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o usertests.o ./Project_Test/XV6_Tests/usertests.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _usertests usertests.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _usertests > usertests.asm
+	$(OBJDUMP) -t _usertests | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > usertests.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_0/makefileCommandForDebug.txt b/Project_Test/Tests/test_0/makefileCommandForDebug.txt
new file mode 100644
index 0000000..9b3dc3b
--- /dev/null
+++ b/Project_Test/Tests/test_0/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_0/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_0/makefileError.txt b/Project_Test/Tests/test_0/makefileError.txt
new file mode 100644
index 0000000..59e39ae
--- /dev/null
+++ b/Project_Test/Tests/test_0/makefileError.txt
@@ -0,0 +1,89 @@
+$ usertests starting
+arg test passed
+createdelete test
+createdelete ok
+linkunlink test
+linkunlink ok
+concreate test
+concreate ok
+fourfiles test
+fourfiles ok
+sharedfd test
+sharedfd ok
+bigarg test
+bigarg test ok
+bigwrite test
+bigwrite ok
+bigarg test
+bigarg test ok
+bss test
+bss test ok
+sbrk test
+pid 97 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80000000--kill proc
+pid 98 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8000c350--kill proc
+pid 99 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800186a0--kill proc
+pid 100 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800249f0--kill proc
+pid 101 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80030d40--kill proc
+pid 102 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8003d090--kill proc
+pid 103 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800493e0--kill proc
+pid 104 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80055730--kill proc
+pid 105 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80061a80--kill proc
+pid 106 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8006ddd0--kill proc
+pid 107 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8007a120--kill proc
+pid 108 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80086470--kill proc
+pid 109 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800927c0--kill proc
+pid 110 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8009eb10--kill proc
+pid 111 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800aae60--kill proc
+pid 112 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800b71b0--kill proc
+pid 113 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800c3500--kill proc
+pid 114 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800cf850--kill proc
+pid 115 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800dbba0--kill proc
+pid 116 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800e7ef0--kill proc
+pid 117 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800f4240--kill proc
+pid 118 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80100590--kill proc
+pid 119 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8010c8e0--kill proc
+pid 120 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80118c30--kill proc
+pid 121 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80124f80--kill proc
+pid 122 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801312d0--kill proc
+pid 123 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8013d620--kill proc
+pid 124 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80149970--kill proc
+pid 125 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80155cc0--kill proc
+pid 126 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80162010--kill proc
+pid 127 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8016e360--kill proc
+pid 128 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8017a6b0--kill proc
+pid 129 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80186a00--kill proc
+pid 130 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80192d50--kill proc
+pid 131 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8019f0a0--kill proc
+pid 132 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801ab3f0--kill proc
+pid 133 usertests: trap 14 err 5 on cpu 0 eip 0x37af addr 0x801b7740--kill proc
+pid 134 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801c3a90--kill proc
+pid 135 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801cfde0--kill proc
+pid 136 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801dc130--kill proc
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+sbrk test OK
+validate test
+validate ok
+open test
+open test ok
+small file test
+creat small succeeded; ok
+writes ok
+open small succeeded ok
+read succeeded ok
+small file test ok
+big files test
+big files ok
+many creates, followed by unlink test
+many creates, followed by unlink; ok
+openiput test
+openiput test ok
+exitiput test
+exitiput test ok
+iput test
\ No newline at end of file
diff --git a/Project_Test/Tests/test_0/testExpected.txt b/Project_Test/Tests/test_0/testExpected.txt
new file mode 100644
index 0000000..5363373
--- /dev/null
+++ b/Project_Test/Tests/test_0/testExpected.txt
@@ -0,0 +1 @@
+#ALL TESTS PASSED
\ No newline at end of file
diff --git a/Project_Test/Tests/test_0/testInput.txt b/Project_Test/Tests/test_0/testInput.txt
new file mode 100644
index 0000000..10faec3
--- /dev/null
+++ b/Project_Test/Tests/test_0/testInput.txt
@@ -0,0 +1,4 @@
+
+usertests
+
+quitXV6
diff --git a/Project_Test/Tests/test_0/testOutput.txt b/Project_Test/Tests/test_0/testOutput.txt
new file mode 100644
index 0000000..59e39ae
--- /dev/null
+++ b/Project_Test/Tests/test_0/testOutput.txt
@@ -0,0 +1,89 @@
+$ usertests starting
+arg test passed
+createdelete test
+createdelete ok
+linkunlink test
+linkunlink ok
+concreate test
+concreate ok
+fourfiles test
+fourfiles ok
+sharedfd test
+sharedfd ok
+bigarg test
+bigarg test ok
+bigwrite test
+bigwrite ok
+bigarg test
+bigarg test ok
+bss test
+bss test ok
+sbrk test
+pid 97 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80000000--kill proc
+pid 98 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8000c350--kill proc
+pid 99 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800186a0--kill proc
+pid 100 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800249f0--kill proc
+pid 101 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80030d40--kill proc
+pid 102 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8003d090--kill proc
+pid 103 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800493e0--kill proc
+pid 104 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80055730--kill proc
+pid 105 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80061a80--kill proc
+pid 106 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8006ddd0--kill proc
+pid 107 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8007a120--kill proc
+pid 108 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80086470--kill proc
+pid 109 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800927c0--kill proc
+pid 110 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8009eb10--kill proc
+pid 111 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800aae60--kill proc
+pid 112 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800b71b0--kill proc
+pid 113 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800c3500--kill proc
+pid 114 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800cf850--kill proc
+pid 115 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800dbba0--kill proc
+pid 116 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800e7ef0--kill proc
+pid 117 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x800f4240--kill proc
+pid 118 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80100590--kill proc
+pid 119 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8010c8e0--kill proc
+pid 120 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80118c30--kill proc
+pid 121 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80124f80--kill proc
+pid 122 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801312d0--kill proc
+pid 123 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8013d620--kill proc
+pid 124 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80149970--kill proc
+pid 125 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80155cc0--kill proc
+pid 126 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80162010--kill proc
+pid 127 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8016e360--kill proc
+pid 128 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8017a6b0--kill proc
+pid 129 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80186a00--kill proc
+pid 130 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x80192d50--kill proc
+pid 131 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x8019f0a0--kill proc
+pid 132 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801ab3f0--kill proc
+pid 133 usertests: trap 14 err 5 on cpu 0 eip 0x37af addr 0x801b7740--kill proc
+pid 134 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801c3a90--kill proc
+pid 135 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801cfde0--kill proc
+pid 136 usertests: trap 14 err 5 on cpu 1 eip 0x37af addr 0x801dc130--kill proc
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+allocuvm out of memory
+sbrk test OK
+validate test
+validate ok
+open test
+open test ok
+small file test
+creat small succeeded; ok
+writes ok
+open small succeeded ok
+read succeeded ok
+small file test ok
+big files test
+big files ok
+many creates, followed by unlink test
+many creates, followed by unlink; ok
+openiput test
+openiput test ok
+exitiput test
+exitiput test ok
+iput test
\ No newline at end of file
diff --git a/Project_Test/Tests/test_1/Makefile b/Project_Test/Tests/test_1/Makefile
new file mode 100644
index 0000000..685c2c4
--- /dev/null
+++ b/Project_Test/Tests/test_1/Makefile
@@ -0,0 +1,312 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_1/makefileCommandForDebug.txt b/Project_Test/Tests/test_1/makefileCommandForDebug.txt
new file mode 100644
index 0000000..2718967
--- /dev/null
+++ b/Project_Test/Tests/test_1/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_1/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_1/testExpected.txt b/Project_Test/Tests/test_1/testExpected.txt
new file mode 100644
index 0000000..8cc50d6
--- /dev/null
+++ b/Project_Test/Tests/test_1/testExpected.txt
@@ -0,0 +1,3 @@
+$ fork test
+fork test OK
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_1/testInput.txt b/Project_Test/Tests/test_1/testInput.txt
new file mode 100644
index 0000000..aeb0d63
--- /dev/null
+++ b/Project_Test/Tests/test_1/testInput.txt
@@ -0,0 +1,4 @@
+
+forktest
+    
+quitXV6
diff --git a/Project_Test/Tests/test_1/testOutput.txt b/Project_Test/Tests/test_1/testOutput.txt
new file mode 100644
index 0000000..8cc50d6
--- /dev/null
+++ b/Project_Test/Tests/test_1/testOutput.txt
@@ -0,0 +1,3 @@
+$ fork test
+fork test OK
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_10/Makefile b/Project_Test/Tests/test_10/Makefile
new file mode 100644
index 0000000..543a3b8
--- /dev/null
+++ b/Project_Test/Tests/test_10/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest5\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest5: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest5.o ./Project_Test/XV6_Tests/schedulingTest5.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest5 schedulingTest5.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest5 > schedulingTest5.asm
+	$(OBJDUMP) -t _schedulingTest5 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest5.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_10/makefileCommandForDebug.txt b/Project_Test/Tests/test_10/makefileCommandForDebug.txt
new file mode 100644
index 0000000..b124866
--- /dev/null
+++ b/Project_Test/Tests/test_10/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_10/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_10/makefileError.txt b/Project_Test/Tests/test_10/makefileError.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_10/makefileError.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_10/testExpected.txt b/Project_Test/Tests/test_10/testExpected.txt
new file mode 100644
index 0000000..279b988
--- /dev/null
+++ b/Project_Test/Tests/test_10/testExpected.txt
@@ -0,0 +1,63 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_10/testInput.txt b/Project_Test/Tests/test_10/testInput.txt
new file mode 100644
index 0000000..ae1a475
--- /dev/null
+++ b/Project_Test/Tests/test_10/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest5
+    
+quitXV6
diff --git a/Project_Test/Tests/test_10/testOutput.txt b/Project_Test/Tests/test_10/testOutput.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_10/testOutput.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_11/Makefile b/Project_Test/Tests/test_11/Makefile
new file mode 100644
index 0000000..aeec2cc
--- /dev/null
+++ b/Project_Test/Tests/test_11/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest6\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest6.o ./Project_Test/XV6_Tests/schedulingTest6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest6 schedulingTest6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest6 > schedulingTest6.asm
+	$(OBJDUMP) -t _schedulingTest6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest6.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_11/makefileCommandForDebug.txt b/Project_Test/Tests/test_11/makefileCommandForDebug.txt
new file mode 100644
index 0000000..56a6623
--- /dev/null
+++ b/Project_Test/Tests/test_11/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_11/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_11/makefileError.txt b/Project_Test/Tests/test_11/makefileError.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_11/makefileError.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_11/testExpected.txt b/Project_Test/Tests/test_11/testExpected.txt
new file mode 100644
index 0000000..279b988
--- /dev/null
+++ b/Project_Test/Tests/test_11/testExpected.txt
@@ -0,0 +1,63 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_11/testInput.txt b/Project_Test/Tests/test_11/testInput.txt
new file mode 100644
index 0000000..8b216a1
--- /dev/null
+++ b/Project_Test/Tests/test_11/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest6
+    
+quitXV6
diff --git a/Project_Test/Tests/test_11/testOutput.txt b/Project_Test/Tests/test_11/testOutput.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_11/testOutput.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_12/Makefile b/Project_Test/Tests/test_12/Makefile
new file mode 100644
index 0000000..ee90ecf
--- /dev/null
+++ b/Project_Test/Tests/test_12/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest7\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest7: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest7.o ./Project_Test/XV6_Tests/schedulingTest7.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest7 schedulingTest7.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest7 > schedulingTest7.asm
+	$(OBJDUMP) -t _schedulingTest7 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest7.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_12/makefileCommandForDebug.txt b/Project_Test/Tests/test_12/makefileCommandForDebug.txt
new file mode 100644
index 0000000..42d66f4
--- /dev/null
+++ b/Project_Test/Tests/test_12/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_12/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_12/testExpected.txt b/Project_Test/Tests/test_12/testExpected.txt
new file mode 100644
index 0000000..047eac4
--- /dev/null
+++ b/Project_Test/Tests/test_12/testExpected.txt
@@ -0,0 +1,2 @@
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_12/testInput.txt b/Project_Test/Tests/test_12/testInput.txt
new file mode 100644
index 0000000..02639df
--- /dev/null
+++ b/Project_Test/Tests/test_12/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest7
+    
+quitXV6
diff --git a/Project_Test/Tests/test_12/testOutput.txt b/Project_Test/Tests/test_12/testOutput.txt
new file mode 100644
index 0000000..047eac4
--- /dev/null
+++ b/Project_Test/Tests/test_12/testOutput.txt
@@ -0,0 +1,2 @@
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_13/Makefile b/Project_Test/Tests/test_13/Makefile
new file mode 100644
index 0000000..a21a9dc
--- /dev/null
+++ b/Project_Test/Tests/test_13/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest8\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest8: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest8.o ./Project_Test/XV6_Tests/schedulingTest8.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest8 schedulingTest8.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest8 > schedulingTest8.asm
+	$(OBJDUMP) -t _schedulingTest8 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest8.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_13/makefileCommandForDebug.txt b/Project_Test/Tests/test_13/makefileCommandForDebug.txt
new file mode 100644
index 0000000..935c43b
--- /dev/null
+++ b/Project_Test/Tests/test_13/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_13/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_13/testExpected.txt b/Project_Test/Tests/test_13/testExpected.txt
new file mode 100644
index 0000000..047eac4
--- /dev/null
+++ b/Project_Test/Tests/test_13/testExpected.txt
@@ -0,0 +1,2 @@
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_13/testInput.txt b/Project_Test/Tests/test_13/testInput.txt
new file mode 100644
index 0000000..1b868c5
--- /dev/null
+++ b/Project_Test/Tests/test_13/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest8
+    
+quitXV6
diff --git a/Project_Test/Tests/test_13/testOutput.txt b/Project_Test/Tests/test_13/testOutput.txt
new file mode 100644
index 0000000..047eac4
--- /dev/null
+++ b/Project_Test/Tests/test_13/testOutput.txt
@@ -0,0 +1,2 @@
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_14/Makefile b/Project_Test/Tests/test_14/Makefile
new file mode 100644
index 0000000..b5c5f87
--- /dev/null
+++ b/Project_Test/Tests/test_14/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest9\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest9: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest9.o ./Project_Test/XV6_Tests/schedulingTest9.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest9 schedulingTest9.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest9 > schedulingTest9.asm
+	$(OBJDUMP) -t _schedulingTest9 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest9.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_14/makefileCommandForDebug.txt b/Project_Test/Tests/test_14/makefileCommandForDebug.txt
new file mode 100644
index 0000000..1782bac
--- /dev/null
+++ b/Project_Test/Tests/test_14/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_14/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_14/testExpected.txt b/Project_Test/Tests/test_14/testExpected.txt
new file mode 100644
index 0000000..4488fba
--- /dev/null
+++ b/Project_Test/Tests/test_14/testExpected.txt
@@ -0,0 +1,2 @@
+$ 00000000009999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_14/testInput.txt b/Project_Test/Tests/test_14/testInput.txt
new file mode 100644
index 0000000..53590eb
--- /dev/null
+++ b/Project_Test/Tests/test_14/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest9
+    
+quitXV6
diff --git a/Project_Test/Tests/test_14/testOutput.txt b/Project_Test/Tests/test_14/testOutput.txt
new file mode 100644
index 0000000..4488fba
--- /dev/null
+++ b/Project_Test/Tests/test_14/testOutput.txt
@@ -0,0 +1,2 @@
+$ 00000000009999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_15/Makefile b/Project_Test/Tests/test_15/Makefile
new file mode 100644
index 0000000..72bea25
--- /dev/null
+++ b/Project_Test/Tests/test_15/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest10\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest10: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest10.o ./Project_Test/XV6_Tests/schedulingTest10.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest10 schedulingTest10.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest10 > schedulingTest10.asm
+	$(OBJDUMP) -t _schedulingTest10 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest10.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_15/makefileCommandForDebug.txt b/Project_Test/Tests/test_15/makefileCommandForDebug.txt
new file mode 100644
index 0000000..cc41116
--- /dev/null
+++ b/Project_Test/Tests/test_15/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_15/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_15/testExpected.txt b/Project_Test/Tests/test_15/testExpected.txt
new file mode 100644
index 0000000..eadd448
--- /dev/null
+++ b/Project_Test/Tests/test_15/testExpected.txt
@@ -0,0 +1,17 @@
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_15/testInput.txt b/Project_Test/Tests/test_15/testInput.txt
new file mode 100644
index 0000000..58e74a5
--- /dev/null
+++ b/Project_Test/Tests/test_15/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest10
+    
+quitXV6
diff --git a/Project_Test/Tests/test_15/testOutput.txt b/Project_Test/Tests/test_15/testOutput.txt
new file mode 100644
index 0000000..adc23ac
--- /dev/null
+++ b/Project_Test/Tests/test_15/testOutput.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_16/Makefile b/Project_Test/Tests/test_16/Makefile
new file mode 100644
index 0000000..c5608ae
--- /dev/null
+++ b/Project_Test/Tests/test_16/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest11\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest11: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest11.o ./Project_Test/XV6_Tests/schedulingTest11.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest11 schedulingTest11.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest11 > schedulingTest11.asm
+	$(OBJDUMP) -t _schedulingTest11 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest11.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_16/testExpected.txt b/Project_Test/Tests/test_16/testExpected.txt
new file mode 100644
index 0000000..eadd448
--- /dev/null
+++ b/Project_Test/Tests/test_16/testExpected.txt
@@ -0,0 +1,17 @@
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_16/testInput.txt b/Project_Test/Tests/test_16/testInput.txt
new file mode 100644
index 0000000..ac61877
--- /dev/null
+++ b/Project_Test/Tests/test_16/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest11
+    
+quitXV6
diff --git a/Project_Test/Tests/test_17/testExpected.txt b/Project_Test/Tests/test_17/testExpected.txt
new file mode 100644
index 0000000..eadd448
--- /dev/null
+++ b/Project_Test/Tests/test_17/testExpected.txt
@@ -0,0 +1,17 @@
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_17/testInput.txt b/Project_Test/Tests/test_17/testInput.txt
new file mode 100644
index 0000000..b1e1c50
--- /dev/null
+++ b/Project_Test/Tests/test_17/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest12
+    
+quitXV6
diff --git a/Project_Test/Tests/test_18/testExpected.txt b/Project_Test/Tests/test_18/testExpected.txt
new file mode 100644
index 0000000..d0b4666
--- /dev/null
+++ b/Project_Test/Tests/test_18/testExpected.txt
@@ -0,0 +1,24 @@
+$ Initiating scheduling test, test should take approximately 10000 time quantums !!!
+ctime test 1 ok
+ctime test 2 ok
+ctime test 3 ok
+ctime test 4 ok
+ctime test 5 ok
+stime test 1 ok
+stime test 2 ok
+stime test 3 ok
+stime test 4 ok
+stime test 5 ok
+rutime test 1 ok
+rutime test 2 ok
+rutime test 3 ok
+rutime test 4 ok
+rutime test 5 ok
+ttime test 1 ok
+ttime test 2 ok
+ttime test 3 ok
+ttime test 4 ok
+ttime test 5 ok
+ttime test 6 ok
+ttime test 7 ok
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_18/testInput.txt b/Project_Test/Tests/test_18/testInput.txt
new file mode 100644
index 0000000..5e943ae
--- /dev/null
+++ b/Project_Test/Tests/test_18/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest13
+    
+quitXV6
diff --git a/Project_Test/Tests/test_19/testExpected.txt b/Project_Test/Tests/test_19/testExpected.txt
new file mode 100644
index 0000000..032697b
--- /dev/null
+++ b/Project_Test/Tests/test_19/testExpected.txt
@@ -0,0 +1 @@
++1Hello_World_XV6
\ No newline at end of file
diff --git a/Project_Test/Tests/test_19/testInput.txt b/Project_Test/Tests/test_19/testInput.txt
new file mode 100644
index 0000000..b5d82b6
--- /dev/null
+++ b/Project_Test/Tests/test_19/testInput.txt
@@ -0,0 +1,8 @@
+
+pathTest
+pathTest4
+echo Hello_World_XV6 | cat
+pathTest5
+echo Hello_World_XV6 | cat
+    
+quitXV6
diff --git a/Project_Test/Tests/test_2/Makefile b/Project_Test/Tests/test_2/Makefile
new file mode 100644
index 0000000..2c3c374
--- /dev/null
+++ b/Project_Test/Tests/test_2/Makefile
@@ -0,0 +1,354 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _helloW\
+_pathTest\
+_pathTest1\
+_quitXV6\
+_pathTest2.1\
+_pathTest2.2\
+_pathTest3\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_helloW: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o helloW.o ./Project_Test/XV6_Tests/helloW.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _helloW helloW.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _helloW > helloW.asm
+	$(OBJDUMP) -t _helloW | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > helloW.sym
+
+_pathTest: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o pathTest.o ./Project_Test/XV6_Tests/pathTest.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _pathTest pathTest.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _pathTest > pathTest.asm
+	$(OBJDUMP) -t _pathTest | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > pathTest.sym
+
+_pathTest1: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o pathTest1.o ./Project_Test/XV6_Tests/pathTest1.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _pathTest1 pathTest1.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _pathTest1 > pathTest1.asm
+	$(OBJDUMP) -t _pathTest1 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > pathTest1.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
+_pathTest2.1: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o pathTest2.1.o ./Project_Test/XV6_Tests/pathTest2.1.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _pathTest2.1 pathTest2.1.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _pathTest2.1 > pathTest2.1.asm
+	$(OBJDUMP) -t _pathTest2.1 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > pathTest2.1.sym
+
+_pathTest2.2: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o pathTest2.2.o ./Project_Test/XV6_Tests/pathTest2.2.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _pathTest2.2 pathTest2.2.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _pathTest2.2 > pathTest2.2.asm
+	$(OBJDUMP) -t _pathTest2.2 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > pathTest2.2.sym
+
+_pathTest3: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o pathTest3.o ./Project_Test/XV6_Tests/pathTest3.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _pathTest3 pathTest3.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _pathTest3 > pathTest3.asm
+	$(OBJDUMP) -t _pathTest3 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > pathTest3.sym
+
diff --git a/Project_Test/Tests/test_2/makefileCommandForDebug.txt b/Project_Test/Tests/test_2/makefileCommandForDebug.txt
new file mode 100644
index 0000000..d52c715
--- /dev/null
+++ b/Project_Test/Tests/test_2/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_2/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_2/testExpected.txt b/Project_Test/Tests/test_2/testExpected.txt
new file mode 100644
index 0000000..8ab9bca
--- /dev/null
+++ b/Project_Test/Tests/test_2/testExpected.txt
@@ -0,0 +1 @@
++3Hello World XV6
\ No newline at end of file
diff --git a/Project_Test/Tests/test_2/testInput.txt b/Project_Test/Tests/test_2/testInput.txt
new file mode 100644
index 0000000..ea2dc82
--- /dev/null
+++ b/Project_Test/Tests/test_2/testInput.txt
@@ -0,0 +1,13 @@
+
+pathTest
+helloW
+pathTest1
+helloW
+pathTest2.1
+helloW
+pathTest2.2
+helloW
+pathTest3
+helloW
+    
+quitXV6
diff --git a/Project_Test/Tests/test_2/testOutput.txt b/Project_Test/Tests/test_2/testOutput.txt
new file mode 100644
index 0000000..de02f2b
--- /dev/null
+++ b/Project_Test/Tests/test_2/testOutput.txt
@@ -0,0 +1,28 @@
+$ opening path
+writing to path
+closing path file
+creating /bin/ path
+creating /hello path
+creating /hello/world path
+creating /hello/world/path path
+creating /under path
+creating /under/world path
+creating /under/world/path path
+creating /notIn path
+creating /notIn/path path
+exiting
+$ Hello World XV6
+$ linking helloWorld in /notIn/path
+removing helloWorld from root
+$ returned from exec
+exec helloW failed
+$ linking helloWorld in bin
+$ returned from exec
+Hello World XV6
+$ removing helloWorld from bin
+$ returned from exec
+exec helloW failed
+$ linking helloWorld in /hello/world/path/
+$ returned from exec
+Hello World XV6
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_20/testExpected.txt b/Project_Test/Tests/test_20/testExpected.txt
new file mode 100644
index 0000000..de1a09f
--- /dev/null
+++ b/Project_Test/Tests/test_20/testExpected.txt
@@ -0,0 +1,4 @@
+$ $ "policy 1"
+$ $ "policy 3"
+$ $ "policy 2"
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_20/testInput.txt b/Project_Test/Tests/test_20/testInput.txt
new file mode 100644
index 0000000..9ddd9a0
--- /dev/null
+++ b/Project_Test/Tests/test_20/testInput.txt
@@ -0,0 +1,9 @@
+
+policy 1
+echo "policy 1"
+policy 3
+echo "policy 3"
+policy 2
+echo "policy 2"
+    
+quitXV6
diff --git a/Project_Test/Tests/test_3/Makefile b/Project_Test/Tests/test_3/Makefile
new file mode 100644
index 0000000..f6094e1
--- /dev/null
+++ b/Project_Test/Tests/test_3/Makefile
@@ -0,0 +1,326 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _exitWait\
+_detachTest\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_exitWait: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o exitWait.o ./Project_Test/XV6_Tests/exitWait.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _exitWait exitWait.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _exitWait > exitWait.asm
+	$(OBJDUMP) -t _exitWait | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > exitWait.sym
+
+_detachTest: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o detachTest.o ./Project_Test/XV6_Tests/detachTest.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _detachTest detachTest.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _detachTest > detachTest.asm
+	$(OBJDUMP) -t _detachTest | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > detachTest.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_3/makefileCommandForDebug.txt b/Project_Test/Tests/test_3/makefileCommandForDebug.txt
new file mode 100644
index 0000000..2f14a68
--- /dev/null
+++ b/Project_Test/Tests/test_3/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_3/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_3/testExpected.txt b/Project_Test/Tests/test_3/testExpected.txt
new file mode 100644
index 0000000..9ddf631
--- /dev/null
+++ b/Project_Test/Tests/test_3/testExpected.txt
@@ -0,0 +1,8 @@
+$ 1 child exit status is: 1
+2 child exit status is: 2
+3 child exit status is: 3
+4 child exit status is: 4
+5 child exit status is: 5
+6 child exit status is: 6
+7 child exit status is unknown
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_3/testInput.txt b/Project_Test/Tests/test_3/testInput.txt
new file mode 100644
index 0000000..6cab8ae
--- /dev/null
+++ b/Project_Test/Tests/test_3/testInput.txt
@@ -0,0 +1,4 @@
+
+exitWait
+    
+quitXV6
diff --git a/Project_Test/Tests/test_3/testOutput.txt b/Project_Test/Tests/test_3/testOutput.txt
new file mode 100644
index 0000000..9ddf631
--- /dev/null
+++ b/Project_Test/Tests/test_3/testOutput.txt
@@ -0,0 +1,8 @@
+$ 1 child exit status is: 1
+2 child exit status is: 2
+3 child exit status is: 3
+4 child exit status is: 4
+5 child exit status is: 5
+6 child exit status is: 6
+7 child exit status is unknown
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_4/Makefile b/Project_Test/Tests/test_4/Makefile
new file mode 100644
index 0000000..f6094e1
--- /dev/null
+++ b/Project_Test/Tests/test_4/Makefile
@@ -0,0 +1,326 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _exitWait\
+_detachTest\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_exitWait: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o exitWait.o ./Project_Test/XV6_Tests/exitWait.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _exitWait exitWait.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _exitWait > exitWait.asm
+	$(OBJDUMP) -t _exitWait | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > exitWait.sym
+
+_detachTest: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o detachTest.o ./Project_Test/XV6_Tests/detachTest.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _detachTest detachTest.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _detachTest > detachTest.asm
+	$(OBJDUMP) -t _detachTest | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > detachTest.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_4/makefileCommandForDebug.txt b/Project_Test/Tests/test_4/makefileCommandForDebug.txt
new file mode 100644
index 0000000..5d367a8
--- /dev/null
+++ b/Project_Test/Tests/test_4/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_4/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_4/testExpected.txt b/Project_Test/Tests/test_4/testExpected.txt
new file mode 100644
index 0000000..c121792
--- /dev/null
+++ b/Project_Test/Tests/test_4/testExpected.txt
@@ -0,0 +1,23 @@
+$ detach result for not my child is: -1
+detach result for child 1 is: 0
+detach result for child 2 is: 0
+detach result for child 3 is: 0
+detach result for child 4 is: 0
+detach result for child 5 is: 0
+detach result for child 6 is: 0
+detach result for not my child is: -1
+second detach result for child 1 is: -1
+second detach result for child 2 is: -1
+second detach result for child 3 is: -1
+second detach result for child 4 is: -1
+second detach result for child 5 is: -1
+second detach result for child 6 is: -1
+detach result for not my child is: -1
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+no child left to wait for
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_4/testInput.txt b/Project_Test/Tests/test_4/testInput.txt
new file mode 100644
index 0000000..bc26819
--- /dev/null
+++ b/Project_Test/Tests/test_4/testInput.txt
@@ -0,0 +1,4 @@
+
+detachTest
+    
+quitXV6
diff --git a/Project_Test/Tests/test_4/testOutput.txt b/Project_Test/Tests/test_4/testOutput.txt
new file mode 100644
index 0000000..0eb86ee
--- /dev/null
+++ b/Project_Test/Tests/test_4/testOutput.txt
@@ -0,0 +1,26 @@
+$ Detach failed, no child proccess with pid 77 
+detach result for not my child is: -1
+detach result for child 1 is: 0
+detach result for child 2 is: 0
+detach result for child 3 is: 0
+detach result for child 4 is: 0
+detach result for child 5 is: 0
+detach result for child 6 is: 0
+Detach failed, no child proccess with pid 105 
+detach result for not my child is: -1
+Detach failed, no child proccess with pid 4 
+second detach result for child 1 is: -1
+Detach failed, no child proccess with pid 5 
+second detach result for child 2 is: -1
+Detach failed, no child proccess with pid 6 
+second detach result for child 3 is: -1
+Detach failed, no child proccess with pid 7 
+second detach result for child 4 is: -1
+Detach failed, no child proccess with pid 8 
+second detach result for child 5 is: -1
+Detach failed, no child proccess with pid 9 
+second detach result for child 6 is: -1
+Detach failed, no child proccess with pid 44 
+detach result for not my child is: -1
+no child left to wait for
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_5/Makefile b/Project_Test/Tests/test_5/Makefile
new file mode 100644
index 0000000..11f696f
--- /dev/null
+++ b/Project_Test/Tests/test_5/Makefile
@@ -0,0 +1,326 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _prioritySysTest\
+_policySysTest\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_prioritySysTest: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o prioritySysTest.o ./Project_Test/XV6_Tests/prioritySysTest.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _prioritySysTest prioritySysTest.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _prioritySysTest > prioritySysTest.asm
+	$(OBJDUMP) -t _prioritySysTest | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > prioritySysTest.sym
+
+_policySysTest: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o policySysTest.o ./Project_Test/XV6_Tests/policySysTest.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _policySysTest policySysTest.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _policySysTest > policySysTest.asm
+	$(OBJDUMP) -t _policySysTest | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > policySysTest.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_5/makefileCommandForDebug.txt b/Project_Test/Tests/test_5/makefileCommandForDebug.txt
new file mode 100644
index 0000000..8a01adf
--- /dev/null
+++ b/Project_Test/Tests/test_5/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_5/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_5/makefileError.txt b/Project_Test/Tests/test_5/makefileError.txt
new file mode 100644
index 0000000..0c0f712
--- /dev/null
+++ b/Project_Test/Tests/test_5/makefileError.txt
@@ -0,0 +1,7 @@
+$ Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+lapicid 1: panic: Priorety is not in allowed range
+ 801042a7 80106ce8 80105f4e 80107119 80106e52 0 0 0 0 0
\ No newline at end of file
diff --git a/Project_Test/Tests/test_5/testExpected.txt b/Project_Test/Tests/test_5/testExpected.txt
new file mode 100644
index 0000000..21d6b9e
--- /dev/null
+++ b/Project_Test/Tests/test_5/testExpected.txt
@@ -0,0 +1,29 @@
+$ Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with wrong args
+Calling priority system call with wrong args
+Calling priority system call with wrong args
+$ Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling policy system call
+Calling priority system call with correct args
+Calling priority system call with wrong args
+Calling policy system call
+Calling priority system call with wrong args
+Calling policy system call
+Calling priority system call with wrong args
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_5/testInput.txt b/Project_Test/Tests/test_5/testInput.txt
new file mode 100644
index 0000000..82b57e2
--- /dev/null
+++ b/Project_Test/Tests/test_5/testInput.txt
@@ -0,0 +1,5 @@
+
+prioritySysTest
+policySysTest
+    
+quitXV6
diff --git a/Project_Test/Tests/test_5/testOutput.txt b/Project_Test/Tests/test_5/testOutput.txt
new file mode 100644
index 0000000..0c0f712
--- /dev/null
+++ b/Project_Test/Tests/test_5/testOutput.txt
@@ -0,0 +1,7 @@
+$ Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+lapicid 1: panic: Priorety is not in allowed range
+ 801042a7 80106ce8 80105f4e 80107119 80106e52 0 0 0 0 0
\ No newline at end of file
diff --git a/Project_Test/Tests/test_6/Makefile b/Project_Test/Tests/test_6/Makefile
new file mode 100644
index 0000000..f5f326c
--- /dev/null
+++ b/Project_Test/Tests/test_6/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest1\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest1: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest1.o ./Project_Test/XV6_Tests/schedulingTest1.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest1 schedulingTest1.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest1 > schedulingTest1.asm
+	$(OBJDUMP) -t _schedulingTest1 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest1.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_6/makefileCommandForDebug.txt b/Project_Test/Tests/test_6/makefileCommandForDebug.txt
new file mode 100644
index 0000000..01e109f
--- /dev/null
+++ b/Project_Test/Tests/test_6/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_6/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_6/makefileError.txt b/Project_Test/Tests/test_6/makefileError.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_6/makefileError.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_6/testExpected.txt b/Project_Test/Tests/test_6/testExpected.txt
new file mode 100644
index 0000000..d52b5a1
--- /dev/null
+++ b/Project_Test/Tests/test_6/testExpected.txt
@@ -0,0 +1,44 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_6/testInput.txt b/Project_Test/Tests/test_6/testInput.txt
new file mode 100644
index 0000000..5fa919c
--- /dev/null
+++ b/Project_Test/Tests/test_6/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest1
+    
+quitXV6
diff --git a/Project_Test/Tests/test_6/testOutput.txt b/Project_Test/Tests/test_6/testOutput.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_6/testOutput.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_7/Makefile b/Project_Test/Tests/test_7/Makefile
new file mode 100644
index 0000000..ccad4ed
--- /dev/null
+++ b/Project_Test/Tests/test_7/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest2\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest2: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest2.o ./Project_Test/XV6_Tests/schedulingTest2.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest2 schedulingTest2.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest2 > schedulingTest2.asm
+	$(OBJDUMP) -t _schedulingTest2 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest2.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_7/makefileCommandForDebug.txt b/Project_Test/Tests/test_7/makefileCommandForDebug.txt
new file mode 100644
index 0000000..89aa636
--- /dev/null
+++ b/Project_Test/Tests/test_7/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_7/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_7/makefileError.txt b/Project_Test/Tests/test_7/makefileError.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_7/makefileError.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_7/testExpected.txt b/Project_Test/Tests/test_7/testExpected.txt
new file mode 100644
index 0000000..d52b5a1
--- /dev/null
+++ b/Project_Test/Tests/test_7/testExpected.txt
@@ -0,0 +1,44 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_7/testInput.txt b/Project_Test/Tests/test_7/testInput.txt
new file mode 100644
index 0000000..54a6e8b
--- /dev/null
+++ b/Project_Test/Tests/test_7/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest2
+    
+quitXV6
diff --git a/Project_Test/Tests/test_7/testOutput.txt b/Project_Test/Tests/test_7/testOutput.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_7/testOutput.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_8/Makefile b/Project_Test/Tests/test_8/Makefile
new file mode 100644
index 0000000..dc24d3a
--- /dev/null
+++ b/Project_Test/Tests/test_8/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest3\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest3: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest3.o ./Project_Test/XV6_Tests/schedulingTest3.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest3 schedulingTest3.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest3 > schedulingTest3.asm
+	$(OBJDUMP) -t _schedulingTest3 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest3.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_8/makefileCommandForDebug.txt b/Project_Test/Tests/test_8/makefileCommandForDebug.txt
new file mode 100644
index 0000000..5a342f9
--- /dev/null
+++ b/Project_Test/Tests/test_8/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_8/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_8/makefileError.txt b/Project_Test/Tests/test_8/makefileError.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_8/makefileError.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_8/testExpected.txt b/Project_Test/Tests/test_8/testExpected.txt
new file mode 100644
index 0000000..d52b5a1
--- /dev/null
+++ b/Project_Test/Tests/test_8/testExpected.txt
@@ -0,0 +1,44 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_8/testInput.txt b/Project_Test/Tests/test_8/testInput.txt
new file mode 100644
index 0000000..9051d6c
--- /dev/null
+++ b/Project_Test/Tests/test_8/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest3
+    
+quitXV6
diff --git a/Project_Test/Tests/test_8/testOutput.txt b/Project_Test/Tests/test_8/testOutput.txt
new file mode 100644
index 0000000..0d85e27
--- /dev/null
+++ b/Project_Test/Tests/test_8/testOutput.txt
@@ -0,0 +1 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
\ No newline at end of file
diff --git a/Project_Test/Tests/test_9/Makefile b/Project_Test/Tests/test_9/Makefile
new file mode 100644
index 0000000..2515763
--- /dev/null
+++ b/Project_Test/Tests/test_9/Makefile
@@ -0,0 +1,319 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	ass1ds.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# To compile and run on mac OS uncumment the following line.
+# TOOLPREFIX = i386-elf-
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX =
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+# QEMU = /opt/local/bin/qemu-system-i386
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+GPP = $(TOOLPREFIX)g++
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+CFLAGS = -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer
+CPPFLAGS += $(shell $(GPP) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+# CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CPPFLAGS += -fno-pie -no-pie
+endif
+
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+ifneq ($(shell $(GPP) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CPPFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+ass1ds.o:
+	$(GPP) -std=gnu++11 $(CPPFLAGS) -c ass1ds.cpp -o ass1ds.o
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=  _schedulingTest4\
+_quitXV6\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_wc\
+	_zombie\
+	_policy\
+	_tests\
+	_test\
+
+fs.img: mkfs README  $(UPROGS)
+	./mkfs fs.img README  $(UPROGS)
+
+-include *.d
+
+clean:
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
+_schedulingTest4: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o schedulingTest4.o ./Project_Test/XV6_Tests/schedulingTest4.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _schedulingTest4 schedulingTest4.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _schedulingTest4 > schedulingTest4.asm
+	$(OBJDUMP) -t _schedulingTest4 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > schedulingTest4.sym
+
+_quitXV6: ulib.o usys.o printf.o umalloc.o
+	gcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer 	-fno-stack-protector -fno-pie -no-pie -fno-pic -static 	-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o quitXV6.o ./Project_Test/XV6_Tests/quitXV6.c
+	ld -m    elf_i386 -N -e main -Ttext 0 -o _quitXV6 quitXV6.o ulib.o usys.o printf.o umalloc.o
+	objdump -S _quitXV6 > quitXV6.asm
+	$(OBJDUMP) -t _quitXV6 | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > quitXV6.sym
+
diff --git a/Project_Test/Tests/test_9/makefileCommandForDebug.txt b/Project_Test/Tests/test_9/makefileCommandForDebug.txt
new file mode 100644
index 0000000..4b7701c
--- /dev/null
+++ b/Project_Test/Tests/test_9/makefileCommandForDebug.txt
@@ -0,0 +1 @@
+make --makefile=./Project_Test/Tests/test_9/Makefile clean qemu 
\ No newline at end of file
diff --git a/Project_Test/Tests/test_9/makefileError.txt b/Project_Test/Tests/test_9/makefileError.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_9/makefileError.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_9/testExpected.txt b/Project_Test/Tests/test_9/testExpected.txt
new file mode 100644
index 0000000..279b988
--- /dev/null
+++ b/Project_Test/Tests/test_9/testExpected.txt
@@ -0,0 +1,63 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
\ No newline at end of file
diff --git a/Project_Test/Tests/test_9/testInput.txt b/Project_Test/Tests/test_9/testInput.txt
new file mode 100644
index 0000000..64b87b4
--- /dev/null
+++ b/Project_Test/Tests/test_9/testInput.txt
@@ -0,0 +1,4 @@
+
+schedulingTest4
+    
+quitXV6
diff --git a/Project_Test/Tests/test_9/testOutput.txt b/Project_Test/Tests/test_9/testOutput.txt
new file mode 100644
index 0000000..3cde939
--- /dev/null
+++ b/Project_Test/Tests/test_9/testOutput.txt
@@ -0,0 +1,2 @@
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+Allready in this policy, doing nothing...
\ No newline at end of file
diff --git a/Project_Test/XV6_Tests/detachTest.c b/Project_Test/XV6_Tests/detachTest.c
new file mode 100644
index 0000000..3a60eed
--- /dev/null
+++ b/Project_Test/XV6_Tests/detachTest.c
@@ -0,0 +1,109 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    int pidChild1;
+    int pidChild2;
+    int pidChild3;
+    int pidChild4;
+    int pidChild5;
+    int pidChild6;
+    int detachResult;
+    int secToWait = 500;
+    
+    if((pidChild1 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+
+    if((pidChild2 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+
+    if((pidChild3 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+
+    if((pidChild4 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+
+    if((pidChild5 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+
+    if((pidChild6 = fork()) == 0){
+        sleep(secToWait);
+        exit(secToWait);
+    }
+    
+    detachResult = detach(77);
+    printf(1,"detach result for not my child is: %d\n",detachResult);
+
+    detachResult = detach(pidChild1);
+    printf(1,"detach result for child 1 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild2);
+    printf(1,"detach result for child 2 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild3);
+    printf(1,"detach result for child 3 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild4);
+    printf(1,"detach result for child 4 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild5);
+    printf(1,"detach result for child 5 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild6);
+    printf(1,"detach result for child 6 is: %d\n",detachResult);
+
+    detachResult = detach(105);
+    printf(1,"detach result for not my child is: %d\n",detachResult);
+
+    detachResult = detach(pidChild1);
+    printf(1,"second detach result for child 1 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild2);
+    printf(1,"second detach result for child 2 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild3);
+    printf(1,"second detach result for child 3 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild4);
+    printf(1,"second detach result for child 4 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild5);
+    printf(1,"second detach result for child 5 is: %d\n",detachResult);
+
+    detachResult = detach(pidChild6);
+    printf(1,"second detach result for child 6 is: %d\n",detachResult);
+
+    detachResult = detach(44);
+    printf(1,"detach result for not my child is: %d\n",detachResult);
+    
+    sleep(secToWait * 2);
+
+    if(wait(null) != -1){
+        printf(1,"Succeded in waiting for a child, possible detach error\n");
+    }
+    else{
+        printf(1,"no child left to wait for\n");
+    }
+
+    exit(0);
+
+}
+
+
diff --git a/Project_Test/XV6_Tests/exitWait.c b/Project_Test/XV6_Tests/exitWait.c
new file mode 100644
index 0000000..2706c11
--- /dev/null
+++ b/Project_Test/XV6_Tests/exitWait.c
@@ -0,0 +1,73 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    int childExit1;
+    int childExit2;
+    int childExit3;
+    int childExit4;
+    int childExit5;
+    int childExit6;
+    int secToWait = 100;
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(1);
+    }
+    wait(&childExit1);
+    printf(1,"1 child exit status is: %d\n",childExit1);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(2);
+    }
+    wait(&childExit2);
+    printf(1,"2 child exit status is: %d\n",childExit2);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(3);
+    }
+    wait(&childExit3);
+    printf(1,"3 child exit status is: %d\n",childExit3);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(4);
+    }
+    wait(&childExit4);
+    printf(1,"4 child exit status is: %d\n",childExit4);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(5);
+    }
+    wait(&childExit5);
+    printf(1,"5 child exit status is: %d\n",childExit5);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(6);
+    }
+    wait(&childExit6);
+    printf(1,"6 child exit status is: %d\n",childExit6);
+
+    if(fork() == 0){
+        sleep(secToWait);
+        exit(7);
+    }
+    wait(null);
+    printf(1,"7 child exit status is unknown\n");
+
+    exit(0);
+
+}
+
+
diff --git a/Project_Test/XV6_Tests/helloW.c b/Project_Test/XV6_Tests/helloW.c
new file mode 100644
index 0000000..786b96b
--- /dev/null
+++ b/Project_Test/XV6_Tests/helloW.c
@@ -0,0 +1,14 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    printf(1,"Hello World XV6\n");
+    exit(0);
+}
diff --git a/Project_Test/XV6_Tests/pathTest.c b/Project_Test/XV6_Tests/pathTest.c
new file mode 100644
index 0000000..7963653
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest.c
@@ -0,0 +1,124 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    int fd;
+    int writed;
+
+    printf(1,"opening path\n");
+    fd = open("/path",O_WRONLY);
+
+    if(fd < 0){
+        printf(1,"Error in opening path file\n");
+        exit(0);
+    }
+
+    const char * path = "/:/bin/:/hello/world/path/:/under/world/path";
+    
+    printf(1,"writing to path\n");
+    writed = write(fd,path,strlen(path));
+    
+    if(writed != strlen(path)){
+        printf(1,"error in writing to path, %d were written\n",writed);
+    }
+
+    printf(1,"closing path file\n");
+    close(fd);
+    
+    char * command;
+    char *args[4];
+
+    printf(1,"creating /bin/ path\n");
+    args[0] = "/mkdir";
+    args[1] = "/bin/";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+    
+    printf(1,"creating /hello path\n");
+    args[0] = "/mkdir";
+    args[1] = "/hello";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /hello/world path\n");
+    args[0] = "/mkdir";
+    args[1] = "/hello/world";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /hello/world/path path\n");
+    args[0] = "/mkdir";
+    args[1] = "/hello/world/path";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /under path\n");
+    args[0] = "/mkdir";
+    args[1] = "/under";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /under/world path\n");
+    args[0] = "/mkdir";
+    args[1] = "/under/world";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /under/world/path path\n");
+    args[0] = "/mkdir";
+    args[1] = "/under/world/path";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /notIn path\n");
+    args[0] = "/mkdir";
+    args[1] = "/notIn";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"creating /notIn/path path\n");
+    args[0] = "/mkdir";
+    args[1] = "/notIn/path";
+    args[2] = 0;
+    command = "/mkdir";
+    execute(command,args);
+
+    printf(1,"exiting\n");
+
+    exit(0);
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/pathTest1.c b/Project_Test/XV6_Tests/pathTest1.c
new file mode 100644
index 0000000..c930d52
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest1.c
@@ -0,0 +1,65 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+
+    printf(1,"linking helloWorld in /notIn/path\n");
+    args[0] = "/ln";
+    args[1] = "/helloW";
+    args[2] = "/notIn/path/helloW";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+
+    printf(1,"removing helloWorld from root\n");
+    args[0] = "/rm";
+    args[1] = "/helloW";
+    args[2] = 0;
+    command = "/rm";
+    execute(command,args);
+
+    exit(0);
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
+
+    
+
+
+  
+
+
+
+
+
+
+
+  
+
diff --git a/Project_Test/XV6_Tests/pathTest2.1.c b/Project_Test/XV6_Tests/pathTest2.1.c
new file mode 100644
index 0000000..ae62925
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest2.1.c
@@ -0,0 +1,45 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+    
+    printf(1,"linking helloWorld in bin\n");
+    args[0] = "/ln";
+    args[1] = "/notIn/path/helloW";
+    args[2] = "/bin/helloW";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+
+    exit(0);
+
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/pathTest2.2.c b/Project_Test/XV6_Tests/pathTest2.2.c
new file mode 100644
index 0000000..86e4578
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest2.2.c
@@ -0,0 +1,43 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+
+    printf(1,"removing helloWorld from bin\n");
+    args[0] = "/rm";
+    args[1] = "/bin/helloW";
+    args[2] = 0;
+    command = "/rm";
+    execute(command,args);
+
+    exit(0);
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/pathTest3.c b/Project_Test/XV6_Tests/pathTest3.c
new file mode 100644
index 0000000..6b27ec2
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest3.c
@@ -0,0 +1,45 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+
+    printf(1,"linking helloWorld in /hello/world/path/\n");
+    args[0] = "/ln";
+    args[1] = "/notIn/path/helloW";
+    args[2] = "/hello/world/path/helloW";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+
+    exit(0);
+
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/pathTest4.c b/Project_Test/XV6_Tests/pathTest4.c
new file mode 100644
index 0000000..ce8af45
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest4.c
@@ -0,0 +1,68 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+
+    printf(1,"copying cat to /notIn/path/cat\n");
+    args[0] = "/ln";
+    args[1] = "/cat";
+    args[2] = "/notIn/path/cat";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+    
+    printf(1,"copying echo to /notIn/path/echo\n");
+    args[0] = "/ln";
+    args[1] = "/echo";
+    args[2] = "/notIn/path/echo";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+
+    printf(1,"removing /cat\n");
+    args[0] = "/rm";
+    args[1] = "/cat";
+    args[2] = 0;
+    command = "/rm";
+    execute(command,args);
+
+    printf(1,"removing /echo\n");
+    args[0] = "/rm";
+    args[1] = "/echo";
+    args[2] = 0;
+    command = "/rm";
+    execute(command,args);
+
+    printf(1,"exiting\n");
+
+    exit(0);
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/pathTest5.c b/Project_Test/XV6_Tests/pathTest5.c
new file mode 100644
index 0000000..1691bc3
--- /dev/null
+++ b/Project_Test/XV6_Tests/pathTest5.c
@@ -0,0 +1,54 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+void execute(char * command, char** args);
+
+int main(int argc, char *argv[]){
+    char * command;
+    char *args[4];
+
+    printf(1,"copying /notIn/path/cat to /bin/cat\n");
+    args[0] = "/ln";
+    args[1] = "/notIn/path/cat";
+    args[2] = "/bin/cat";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+    
+    printf(1,"copying /notIn/path/echo to /hello/world/path/echo\n");
+    args[0] = "/ln";
+    args[1] = "notIn/path/echo";
+    args[2] = "/hello/world/path/echo";
+    args[3] = 0;
+    command = "/ln";
+    execute(command,args);
+
+    printf(1,"exiting\n");
+
+    exit(0);
+}
+
+void execute(char * command, char** args){
+    int pid;
+
+    if((pid = fork()) == 0){
+        exec(command, args);
+        printf(1, "exec %s failed\n", command);
+    }
+    else if(pid > 0){
+        //printf(1,"waiting for exec of %s to finish\n",command);
+        wait(null);
+        //printf(1,"%s exec exited\n",command);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+
+}
diff --git a/Project_Test/XV6_Tests/policySysTest.c b/Project_Test/XV6_Tests/policySysTest.c
new file mode 100644
index 0000000..d4670dc
--- /dev/null
+++ b/Project_Test/XV6_Tests/policySysTest.c
@@ -0,0 +1,70 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    printf(1,"Calling priority system call with correct args\n");
+    priority(4);
+
+    printf(1,"Calling policy system call\n");
+    policy(1);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(1);
+
+    printf(1,"Calling policy system call\n");
+    policy(2);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(9);
+
+    printf(1,"Calling policy system call\n");
+    policy(3);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(10);
+
+    printf(1,"Calling policy system call\n");
+    policy(3);
+    
+    printf(1,"Calling priority system call with correct args\n");
+    priority(0);
+
+    printf(1,"Calling policy system call\n");
+    policy(2);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(0);
+
+    printf(1,"Calling policy system call\n");
+    policy(1);
+
+    printf(1,"Calling policy system call\n");
+    policy(1);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(5);
+
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(-20);
+
+    printf(1,"Calling policy system call\n");
+    policy(1);
+
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(-1);
+
+    printf(1,"Calling policy system call\n");
+    policy(3);
+    
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(11);
+
+    exit(0);
+}
diff --git a/Project_Test/XV6_Tests/prioritySysTest.c b/Project_Test/XV6_Tests/prioritySysTest.c
new file mode 100644
index 0000000..e5ded45
--- /dev/null
+++ b/Project_Test/XV6_Tests/prioritySysTest.c
@@ -0,0 +1,41 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    
+    printf(1,"Calling priority system call with correct args\n");
+    priority(4);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(1);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(9);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(10);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(0);
+
+    printf(1,"Calling priority system call with correct args\n");
+    priority(5);
+
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(-20);
+
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(-1);
+
+    printf(1,"Calling priority system call with wrong args\n");
+    priority(11);
+
+    exit(0);
+}
diff --git a/Project_Test/XV6_Tests/quitXV6.c b/Project_Test/XV6_Tests/quitXV6.c
new file mode 100644
index 0000000..018f70f
--- /dev/null
+++ b/Project_Test/XV6_Tests/quitXV6.c
@@ -0,0 +1,14 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+int main(int argc, char *argv[]){
+    printf(1,"Finished Yehonatan Peleg Test, quiting...\n");
+    exit(0);
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest1.c b/Project_Test/XV6_Tests/schedulingTest1.c
new file mode 100644
index 0000000..cdd97cc
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest1.c
@@ -0,0 +1,161 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+    
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+
+    childPid1 = executeForever(40,"childPid1");
+    childPid2 = executeForever(1,"childPid2");
+    childPid3 = executeForever(2,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(40,"childPid7");
+    childPid8 = executeForever(100,"childPid8");
+    childPid9 = executeForever(4,"childPid9");
+    childPid10 = executeForever(400,"childPid10");
+    childPid11 = executeForever(7,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(200,"childPid14");
+    childPid15 = executeForever(10,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){
+                sleep(timeToSleep);        
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest10.c b/Project_Test/XV6_Tests/schedulingTest10.c
new file mode 100644
index 0000000..7fe259e
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest10.c
@@ -0,0 +1,154 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString);
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    policy(3);
+
+    printf(1,"Initiating scheduling test, test should take approximately 15000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+
+    executeTimes(20,400,0,"childPid16");
+    executeTimes(10,600,0,"childPid17");
+    executeTimes(60,100,0,"childPid18");
+    executeTimes(1000,12,0,"childPid19");
+    executeTimes(200,10,0,"childPid20");
+    
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(0);
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep);   
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(4);
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        if(isDetach){
+            detach(pid);        
+        }
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/Project_Test/XV6_Tests/schedulingTest11.c b/Project_Test/XV6_Tests/schedulingTest11.c
new file mode 100644
index 0000000..919bf2c
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest11.c
@@ -0,0 +1,154 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString);
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    policy(2);
+
+    printf(1,"Initiating scheduling test, test should take approximately 15000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+    executeTimes(20,400,0,"childPid16");
+    executeTimes(10,600,0,"childPid17");
+    executeTimes(60,100,0,"childPid18");
+    executeTimes(1000,12,0,"childPid19");
+    executeTimes(200,10,0,"childPid20");
+ 
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(0);
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep);   
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(4);
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        if(isDetach){
+            detach(pid);        
+        }
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/Project_Test/XV6_Tests/schedulingTest12.c b/Project_Test/XV6_Tests/schedulingTest12.c
new file mode 100644
index 0000000..78d8ef6
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest12.c
@@ -0,0 +1,158 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString);
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    policy(3);
+
+    printf(1,"Initiating scheduling test, test should take approximately 15000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+    executeTimes(20,400,0,"childPid16");
+    executeTimes(10,600,0,"childPid17");
+    executeTimes(60,100,0,"childPid18");
+    executeTimes(1000,12,0,"childPid19");
+    executeTimes(200,10,0,"childPid20");
+    
+    sleep(2000);
+
+    policy(2);
+
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+    wait(null);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(0);
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep);   
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(4);
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        if(isDetach){
+            detach(pid);        
+        }
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/Project_Test/XV6_Tests/schedulingTest13.c b/Project_Test/XV6_Tests/schedulingTest13.c
new file mode 100644
index 0000000..0e47125
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest13.c
@@ -0,0 +1,390 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+#define NUM_OF_CHILDS 7
+
+int executeForever(int timeToSleep,int isDetach,char* debugString);
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString);
+void retrieveNextChildPerf();
+int getChildNum(int pid);
+void print_perf(struct perf performance);
+void print_all_perfs();
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int numOfNotForeverChilds = 5;
+
+int childPids[NUM_OF_CHILDS];
+
+struct perf childPerfs[NUM_OF_CHILDS];
+
+struct perf perf_temp;
+
+int main(int argc, char *argv[]){  
+    policy(1);
+
+    printf(1,"Initiating scheduling test, test should take approximately 10000 time quantums !!!\n");
+    
+    childPids[0] = executeForever(0,0,"childPid0");
+    childPids[1] = executeForever(0,0,"childPid1");
+
+    childPids[2] = executeTimes(10,100,0,"childPid2");
+    childPids[3] = executeTimes(10,300,0,"childPid3");
+    childPids[4] = executeTimes(10,500,0,"childPid4");
+    childPids[5] = executeTimes(10,700,0,"childPid5");
+    childPids[6] = executeTimes(10,900,0,"childPid6");
+    
+     for(int i = 0;i < numOfNotForeverChilds;i++){
+         retrieveNextChildPerf();
+     }
+
+    kill(childPids[0]);
+    kill(childPids[1]);
+    
+   for(int i = 0;i < (NUM_OF_CHILDS - numOfNotForeverChilds);i++){
+         retrieveNextChildPerf();
+     }
+
+    if(childPerfs[1].ctime < childPerfs[0].ctime){
+        printf(1,"error in ctime test 1\n");
+    }
+    else{
+        printf(1,"ctime test 1 ok\n");
+    }
+
+    if(childPerfs[2].ctime < childPerfs[1].ctime){
+        printf(1,"error in ctime test 2\n");
+    }
+    else{
+        printf(1,"ctime test 2 ok\n");
+    }
+
+    if(childPerfs[3].ctime < childPerfs[2].ctime){
+        printf(1,"error in ctime test 3\n");
+    }
+    else{
+        printf(1,"ctime test 3 ok\n");
+    }
+
+    if(childPerfs[4].ctime < childPerfs[3].ctime){
+        printf(1,"error in ctime test 4\n");
+    }
+    else{
+        printf(1,"ctime test 4 ok\n");
+    }
+
+    if(childPerfs[6].ctime < childPerfs[5].ctime){
+        printf(1,"error in ctime test 5\n");
+    }
+    else{
+        printf(1,"ctime test 5 ok\n");
+    }
+
+    // ------------------------------------------------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    
+    // ------------------------------------------------------------------------------------------------------------------------
+
+    if(childPerfs[1].stime != childPerfs[0].stime){
+        printf(1,"error in stime test 1\n");
+    }
+    else{
+        printf(1,"stime test 1 ok\n");
+    }
+
+    if(childPerfs[2].stime < childPerfs[1].stime){
+        printf(1,"error in stime test 2\n");
+    }
+    else{
+        printf(1,"stime test 2 ok\n");
+    }
+
+    if(childPerfs[3].stime < childPerfs[2].stime){
+        printf(1,"error in stime test 3\n");
+    }
+    else{
+        printf(1,"stime test 3 ok\n");
+    }
+
+    if(childPerfs[4].stime < childPerfs[3].stime){
+        printf(1,"error in stime test 4\n");
+    }
+    else{
+        printf(1,"stime test 4 ok\n");
+    }
+
+    if(childPerfs[6].stime < childPerfs[5].stime){
+        printf(1,"error in stime test 5\n");
+    }
+    else{
+        printf(1,"stime test 5 ok\n");
+    }
+ 
+    // ------------------------------------------------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    
+    // ------------------------------------------------------------------------------------------------------------------------
+
+    if(childPerfs[0].rutime < childPerfs[2].rutime){
+        printf(1,"error in rutime test 1\n");
+    }
+    else{
+        printf(1,"rutime test 1 ok\n");
+    }
+
+    if(childPerfs[0].rutime < childPerfs[3].rutime){
+        printf(1,"error in rutime test 2\n");
+    }
+    else{
+        printf(1,"rutime test 2 ok\n");
+    }
+
+    if(childPerfs[0].rutime < childPerfs[4].rutime){
+        printf(1,"error in rutime test 3\n");
+    }
+    else{
+        printf(1,"rutime test 3 ok\n");
+    }
+
+    if(childPerfs[0].rutime < childPerfs[5].rutime){
+        printf(1,"error in rutime test 4\n");
+    }
+    else{
+        printf(1,"rutime test 4 ok\n");
+    }
+
+    if(childPerfs[0].rutime  < childPerfs[6].rutime){
+        printf(1,"error in rutime test 5\n");
+    }
+    else{
+        printf(1,"rutime test 5 ok\n");
+    }
+
+    // ------------------------------------------------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    
+    // ------------------------------------------------------------------------------------------------------------------------
+
+    if((childPerfs[0].rutime + childPerfs[0].retime + childPerfs[0].stime) > (childPerfs[0].ttime - childPerfs[0].ctime + 20)){
+        printf(1,"error in ttime test 1\n");
+    }
+    else{
+        printf(1,"ttime test 1 ok\n");
+    }
+
+    if((childPerfs[1].rutime + childPerfs[1].retime + childPerfs[1].stime) > (childPerfs[1].ttime - childPerfs[1].ctime + 20)){
+        printf(1,"error in ttime test 2\n");
+    }
+    else{
+        printf(1,"ttime test 2 ok\n");
+    }
+
+    if((childPerfs[2].rutime + childPerfs[2].retime + childPerfs[2].stime) > (childPerfs[2].ttime - childPerfs[2].ctime + 20)){
+        printf(1,"error in ttime test 3\n");
+    }
+    else{
+        printf(1,"ttime test 3 ok\n");
+    }
+
+    if((childPerfs[3].rutime + childPerfs[3].retime + childPerfs[3].stime) > (childPerfs[3].ttime - childPerfs[3].ctime + 20)){
+        printf(1,"error in ttime test 4\n");
+    }
+    else{
+        printf(1,"ttime test 4 ok\n");
+    }
+
+    if((childPerfs[4].rutime + childPerfs[4].retime + childPerfs[4].stime) > (childPerfs[4].ttime - childPerfs[4].ctime + 20)){
+        printf(1,"error in ttime test 5\n");
+    }
+    else{
+        printf(1,"ttime test 5 ok\n");
+    }
+    
+    if((childPerfs[5].rutime + childPerfs[5].retime + childPerfs[5].stime) > (childPerfs[5].ttime - childPerfs[5].ctime + 20)){
+        printf(1,"error in ttime test 6\n");
+    }
+    else{
+        printf(1,"ttime test 6 ok\n");
+    }
+
+    if((childPerfs[6].rutime + childPerfs[6].retime + childPerfs[6].stime) > (childPerfs[6].ttime - childPerfs[6].ctime + 20)){
+        printf(1,"error in ttime test 7\n");
+    }
+    else{
+        printf(1,"ttime test 7 ok\n");
+
+    }
+
+    exit(0);
+}
+
+
+int executeForever(int timeToSleep,int isDetach,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep);   
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        if(isDetach){
+            detach(pid);        
+        }
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+int executeTimes(int timeToSleep,int numberOfLoops,int isDetach,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        priority(4);
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        if(isDetach){
+            detach(pid);        
+        }
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void retrieveNextChildPerf(){
+    int pid;
+    int childNum;
+
+    pid = wait_stat(null,&perf_temp);
+    childNum = getChildNum(pid);
+
+    if(childNum != -1){
+        childPerfs[childNum].ctime = perf_temp.ctime;
+        childPerfs[childNum].ttime = perf_temp.ttime;
+        childPerfs[childNum].stime = perf_temp.stime;
+        childPerfs[childNum].retime = perf_temp.retime;
+        childPerfs[childNum].rutime = perf_temp.rutime;
+    }
+    else{
+        printf(1,"couldn't find child num in retrieveNextChildPerf\n");
+    }
+}
+
+int getChildNum(int pid){
+
+    for(int i = 0;i < NUM_OF_CHILDS;i++){
+        if(childPids[i] == pid){
+            return i;
+        }
+    }
+
+    return -1;
+}
+
+void print_perf(struct perf performance){
+    printf(1,"----------------------------------------------------\n");
+    printf(1,"ctime = %d\n",performance.ctime);
+    printf(1,"ttime = %d\n",performance.ttime);
+    printf(1,"stime = %d\n",performance.stime);
+    printf(1,"retime = %d\n",performance.retime);
+    printf(1,"rutime = %d\n",performance.rutime);
+    printf(1,"----------------------------------------------------\n");
+}
+
+void print_all_perfs(){
+    for(int i = 0;i < NUM_OF_CHILDS;i++){
+        print_perf(childPerfs[i]);
+    }
+}
+
+
diff --git a/Project_Test/XV6_Tests/schedulingTest2.c b/Project_Test/XV6_Tests/schedulingTest2.c
new file mode 100644
index 0000000..7618961
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest2.c
@@ -0,0 +1,163 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+    
+    policy(2);
+
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+
+    childPid1 = executeForever(40,"childPid1");
+    childPid2 = executeForever(1,"childPid2");
+    childPid3 = executeForever(2,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(40,"childPid7");
+    childPid8 = executeForever(100,"childPid8");
+    childPid9 = executeForever(4,"childPid9");
+    childPid10 = executeForever(400,"childPid10");
+    childPid11 = executeForever(7,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(200,"childPid14");
+    childPid15 = executeForever(10,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){
+                sleep(timeToSleep);        
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest3.c b/Project_Test/XV6_Tests/schedulingTest3.c
new file mode 100644
index 0000000..8528aff
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest3.c
@@ -0,0 +1,163 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+    
+    policy(3);
+
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+
+    childPid1 = executeForever(40,"childPid1");
+    childPid2 = executeForever(1,"childPid2");
+    childPid3 = executeForever(2,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(40,"childPid7");
+    childPid8 = executeForever(100,"childPid8");
+    childPid9 = executeForever(4,"childPid9");
+    childPid10 = executeForever(400,"childPid10");
+    childPid11 = executeForever(7,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(200,"childPid14");
+    childPid15 = executeForever(10,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(2000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){
+                sleep(timeToSleep);        
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest4.c b/Project_Test/XV6_Tests/schedulingTest4.c
new file mode 100644
index 0000000..45aee40
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest4.c
@@ -0,0 +1,302 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+long long j;
+
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+void executeTimesExhaust(long long numberOfLoops,char* debugString);
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+    
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    executeTestMonitor(5000,5,"TestMonitor");
+
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+    
+    
+    executeTimesExhaust(999999999999999999,"childPid43");
+    executeTimesExhaust(999999999999999999,"childPid44");
+    executeTimesExhaust(999999999999999999,"childPid45");
+    executeTimesExhaust(999999999999999999,"childPid46");
+    executeTimesExhaust(999999999999999999,"childPid47");
+    executeTimesExhaust(999999999999999999,"childPid48");
+    executeTimesExhaust(999999999999999999,"childPid49");
+    executeTimesExhaust(999999999999999999,"childPid50");
+    executeTimesExhaust(999999999999999999,"childPid51");
+    executeTimesExhaust(999999999999999999,"childPid52");
+    executeTimesExhaust(999999999999999999,"childPid53");
+    executeTimesExhaust(999999999999999999,"childPid54");
+    executeTimesExhaust(999999999999999999,"childPid55");
+    executeTimesExhaust(999999999999999999,"childPid56");
+    executeTimesExhaust(999999999999999999,"childPid57");
+    executeTimesExhaust(999999999999999999,"childPid58");
+    executeTimesExhaust(999999999999999999,"childPid59");
+    executeTimesExhaust(999999999999999999,"childPid60");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(5000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){ 
+                sleep(timeToSleep);    
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTimesExhaust(long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                    long long g = 555555555555555555;
+                                                  long long f = 222222222222222222;
+                                                  j = g*f;     
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString){
+    int pid;
+    int changePolicy = 1;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        policy(changePolicy);
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeBetweenLoop);
+
+            if(changePolicy == 3){
+                changePolicy = 1;
+            }
+            else{
+                changePolicy++;
+            }
+
+            policy(changePolicy);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest5.c b/Project_Test/XV6_Tests/schedulingTest5.c
new file mode 100644
index 0000000..78f3593
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest5.c
@@ -0,0 +1,301 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+long long j;
+
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+void executeTimesExhaust(long long numberOfLoops,char* debugString);
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+    
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    executeTestMonitor(1000,25,"TestMonitor");
+
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+
+    executeTimesExhaust(999999999999999999,"childPid43");
+    executeTimesExhaust(999999999999999999,"childPid44");
+    executeTimesExhaust(999999999999999999,"childPid45");
+    executeTimesExhaust(999999999999999999,"childPid46");
+    executeTimesExhaust(999999999999999999,"childPid47");
+    executeTimesExhaust(999999999999999999,"childPid48");
+    executeTimesExhaust(999999999999999999,"childPid49");
+    executeTimesExhaust(999999999999999999,"childPid50");
+    executeTimesExhaust(999999999999999999,"childPid51");
+    executeTimesExhaust(999999999999999999,"childPid52");
+    executeTimesExhaust(999999999999999999,"childPid53");
+    executeTimesExhaust(999999999999999999,"childPid54");
+    executeTimesExhaust(999999999999999999,"childPid55");
+    executeTimesExhaust(999999999999999999,"childPid56");
+    executeTimesExhaust(999999999999999999,"childPid57");
+    executeTimesExhaust(999999999999999999,"childPid58");
+    executeTimesExhaust(999999999999999999,"childPid59");
+    executeTimesExhaust(999999999999999999,"childPid60");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(5000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep); 
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTimesExhaust(long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                        long long g = 555555555555555555;
+                                                  long long f = 222222222222222222;
+                                                  j =  g*f;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString){
+    int pid;
+    int changePolicy = 1;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        policy(changePolicy);
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeBetweenLoop);
+
+            if(changePolicy == 3){
+                changePolicy = 1;
+            }
+            else{
+                changePolicy++;
+            }
+
+            policy(changePolicy);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest6.c b/Project_Test/XV6_Tests/schedulingTest6.c
new file mode 100644
index 0000000..fbb2bdb
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest6.c
@@ -0,0 +1,300 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+long long j;
+int executeForever(int timeToSleep,char* debugString);
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString);
+void executeTimesExhaust(long long numberOfLoops,char* debugString);
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString);
+
+int main(int argc, char *argv[]){  
+
+    printf(1,"Initiating scheduling test, test should take approximately 30000 time quantums !!!\n");
+    int childPid1;
+    int childPid2;
+    int childPid3;
+    int childPid4;
+    int childPid5;
+    int childPid6;
+    int childPid7;
+    int childPid8;
+    int childPid9;
+    int childPid10;
+    int childPid11;
+    int childPid12;
+    int childPid13;
+    int childPid14;
+    int childPid15;
+    
+    executeTestMonitor(500,50,"TestMonitor");
+
+    childPid1 = executeForever(0,"childPid1");
+    childPid2 = executeForever(0,"childPid2");
+    childPid3 = executeForever(0,"childPid3");
+    childPid4 = executeForever(0,"childPid4");
+    childPid5 = executeForever(1000,"childPid5");
+    childPid6 = executeForever(10000,"childPid6");
+    childPid7 = executeForever(0,"childPid7");
+    childPid8 = executeForever(0,"childPid8");
+    childPid9 = executeForever(0,"childPid9");
+    childPid10 = executeForever(0,"childPid10");
+    childPid11 = executeForever(0,"childPid11");
+    childPid12 = executeForever(20000,"childPid12");
+    childPid13 = executeForever(4567,"childPid13");
+    childPid14 = executeForever(0,"childPid14");
+    childPid15 = executeForever(0,"childPid15");
+
+    executeTimes(400,50,"childPid16");
+    executeTimes(4,50,"childPid17");
+    executeTimes(100,100,"childPid18");
+    executeTimes(500,10,"childPid19");
+    executeTimes(1000,15,"childPid20");
+    executeTimes(2000,2,"childPid21");
+    executeTimes(40,22,"childPid22");
+    executeTimes(400,40,"childPid23");
+    executeTimes(4000,5,"childPid24");
+    executeTimes(10,5,"childPid25");
+    executeTimes(5,1,"childPid26");
+    executeTimes(300,30,"childPid27");
+    executeTimes(2000,5,"childPid28");
+    executeTimes(200,20,"childPid29");
+    executeTimes(100,70,"childPid30");
+    executeTimes(200,90,"childPid31");
+    executeTimes(1000,18,"childPid32");
+    executeTimes(20,400,"childPid33");
+    executeTimes(40,200,"childPid34");
+    executeTimes(90,150,"childPid35");
+    executeTimes(9,80,"childPid36");
+    executeTimes(1,140,"childPid37");
+    executeTimes(300,60,"childPid38");
+    executeTimes(90,50,"childPid39");
+    executeTimes(200,30,"childPid40");
+    executeTimes(40,5,"childPid41");
+    executeTimes(2000,2,"childPid42");
+
+    executeTimesExhaust(999999999999999999,"childPid43");
+    executeTimesExhaust(999999999999999999,"childPid44");
+    executeTimesExhaust(999999999999999999,"childPid45");
+    executeTimesExhaust(999999999999999999,"childPid46");
+    executeTimesExhaust(999999999999999999,"childPid47");
+    executeTimesExhaust(999999999999999999,"childPid48");
+    executeTimesExhaust(999999999999999999,"childPid49");
+    executeTimesExhaust(999999999999999999,"childPid50");
+    executeTimesExhaust(999999999999999999,"childPid51");
+    executeTimesExhaust(999999999999999999,"childPid52");
+    executeTimesExhaust(999999999999999999,"childPid53");
+    executeTimesExhaust(999999999999999999,"childPid54");
+    executeTimesExhaust(999999999999999999,"childPid55");
+    executeTimesExhaust(999999999999999999,"childPid56");
+    executeTimesExhaust(999999999999999999,"childPid57");
+    executeTimesExhaust(999999999999999999,"childPid58");
+    executeTimesExhaust(999999999999999999,"childPid59");
+    executeTimesExhaust(999999999999999999,"childPid60");
+
+    sleep(25000);
+
+    kill(childPid1);
+    kill(childPid2);
+    kill(childPid3);
+    kill(childPid4);
+    kill(childPid5);
+    kill(childPid6);
+    kill(childPid7);
+    kill(childPid8);
+    kill(childPid9);
+    kill(childPid10);
+    kill(childPid11);
+    kill(childPid12);
+    kill(childPid13);
+    kill(childPid14);
+    kill(childPid15);
+
+    sleep(5000);
+
+    exit(0);
+}
+
+int executeForever(int timeToSleep,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        while(1){
+            if(timeToSleep){   
+                sleep(timeToSleep); 
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+void executeTimes(int timeToSleep,int numberOfLoops,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeToSleep);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTimesExhaust(long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                        for(int i = 0;i < times;i++){
+            for(int i = 0;i < times;i++){
+                for(int i = 0;i < times;i++){
+                    for(int i = 0;i < times;i++){
+                        for(int i = 0;i < times;i++){
+                            for(int i = 0;i < times;i++){
+                                for(int i = 0;i < times;i++){
+                                    for(int i = 0;i < times;i++){
+                                        for(int i = 0;i < times;i++){
+                                            for(int i = 0;i < times;i++){
+                                                for(int i = 0;i < times;i++){
+                                                   for(int i = 0;i < times;i++){
+                                                  long long g = 555555555555555555;
+                                                  long long f = 222222222222222222;
+                                                  j =  g*f;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
+
+void executeTestMonitor(int timeBetweenLoop,int numberOfLoops,char* debugString){
+    int pid;
+    int changePolicy = 1;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        policy(changePolicy);
+        sleep(1000);
+        for(int i = 0;i < numberOfLoops;i++){
+            sleep(timeBetweenLoop);
+
+            if(changePolicy == 3){
+                changePolicy = 1;
+            }
+            else{
+                changePolicy++;
+            }
+
+            policy(changePolicy);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        exit(0);
+    }
+    else if(pid > 0){
+        detach(pid);
+    }
+    else{
+        printf(1,"fork failed\n");
+    }
+}
diff --git a/Project_Test/XV6_Tests/schedulingTest7.c b/Project_Test/XV6_Tests/schedulingTest7.c
new file mode 100644
index 0000000..25e95bc
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest7.c
@@ -0,0 +1,71 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+char* j;
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    int numberOfEexecutes = 10;
+
+    policy(2);
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(1,999999,"Priority One\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(9,999999,"Priority Two\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes * 2;i++){
+        wait(null);
+    }
+
+    printf(1,"\n");
+
+    exit(0);
+}
+
+int executePriority(int thePriority,long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        priority(thePriority);
+        for(long long i = 0;i < times;i++){
+            j = malloc(sizeof(char) * 100);
+            free(j);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        printf(1,"%d",thePriority);
+
+        exit(0);
+    }
+    else if(pid > 0){
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
diff --git a/Project_Test/XV6_Tests/schedulingTest8.c b/Project_Test/XV6_Tests/schedulingTest8.c
new file mode 100644
index 0000000..a6d7863
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest8.c
@@ -0,0 +1,71 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+
+char* j;
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    int numberOfEexecutes = 10;
+
+    policy(3);
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(1,999999,"Priority One\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(9,999999,"Priority Two\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes * 2;i++){
+        wait(null);
+    }
+
+    printf(1,"\n");
+
+    exit(0);
+}
+
+int executePriority(int thePriority,long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        priority(thePriority);
+        for(int i = 0;i < times;i++){
+            j = malloc(sizeof(char) * 100);
+            free(j);
+        }
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        printf(1,"%d",thePriority);
+
+        exit(0);
+    }
+    else if(pid > 0){
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
diff --git a/Project_Test/XV6_Tests/schedulingTest9.c b/Project_Test/XV6_Tests/schedulingTest9.c
new file mode 100644
index 0000000..f41eb7c
--- /dev/null
+++ b/Project_Test/XV6_Tests/schedulingTest9.c
@@ -0,0 +1,73 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+#define DEBUG 0
+char* j;
+
+int executePriority(int thePriority,long long times,char* debugString);
+
+int main(int argc, char *argv[]){  
+    int numberOfEexecutes = 10;
+
+    policy(3);
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(0,999999,"Priority One\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes;i++){
+        executePriority(9,999999,"Priority Two\n");
+    }
+
+    for(int i = 0;i < numberOfEexecutes * 2;i++){
+        wait(null);
+    }
+
+    printf(1,"\n");
+
+    exit(0);
+}
+
+int executePriority(int thePriority,long long times,char* debugString){
+    int pid;
+
+    if((pid = fork()) == 0){
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," starting...\n");
+        }
+
+        priority(thePriority);
+        for(int i = 0;i < times;i++){
+            j = malloc(sizeof(char) * 100);
+            free(j);
+        }
+        
+
+        if(DEBUG){
+            printf(1,debugString);
+            printf(1," ending...\n");
+        }
+
+        printf(1,"%d",thePriority);
+
+        exit(0);
+    }
+    else if(pid > 0){
+        return pid;
+    }
+    else{
+        printf(1,"fork failed\n");
+        return 0;
+    }
+}
+
+
+
diff --git a/Project_Test/XV6_Tests/usertests.c b/Project_Test/XV6_Tests/usertests.c
new file mode 100644
index 0000000..7633a1f
--- /dev/null
+++ b/Project_Test/XV6_Tests/usertests.c
@@ -0,0 +1,1803 @@
+#include "../../param.h"
+#include "../../types.h"
+#include "../../stat.h"
+#include "../../user.h"
+#include "../../fs.h"
+#include "../../fcntl.h"
+#include "../../syscall.h"
+#include "../../traps.h"
+#include "../../memlayout.h"
+
+char buf[8192];
+char name[3];
+char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+int stdout = 1;
+
+// does chdir() call iput(p->cwd) in a transaction?
+void
+iputtest(void)
+{
+  printf(stdout, "iput test\n");
+
+  if(mkdir("iputdir") < 0){
+    printf(stdout, "mkdir failed\n");
+    exit(0);
+  }
+  if(chdir("iputdir") < 0){
+    printf(stdout, "chdir iputdir failed\n");
+    exit(0);
+  }
+  if(unlink("../iputdir") < 0){
+    printf(stdout, "unlink ../iputdir failed\n");
+    exit(0);
+  }
+  if(chdir("/") < 0){
+    printf(stdout, "chdir / failed\n");
+    exit(0);
+  }
+  printf(stdout, "iput test ok\n");
+}
+
+// does exit(0) call iput(p->cwd) in a transaction?
+void
+exitiputtest(void)
+{
+  int pid;
+
+  printf(stdout, "exitiput test\n");
+
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "fork failed\n");
+    exit(0);
+  }
+  if(pid == 0){
+    if(mkdir("iputdir") < 0){
+      printf(stdout, "mkdir failed\n");
+      exit(0);
+    }
+    if(chdir("iputdir") < 0){
+      printf(stdout, "child chdir failed\n");
+      exit(0);
+    }
+    if(unlink("../iputdir") < 0){
+      printf(stdout, "unlink ../iputdir failed\n");
+      exit(0);
+    }
+    exit(0);
+  }
+  wait(null);
+  printf(stdout, "exitiput test ok\n");
+}
+
+// does the error path in open() for attempt to write a
+// directory call iput() in a transaction?
+// needs a hacked kernel that pauses just after the namei()
+// call in sys_open():
+//    if((ip = namei(path)) == 0)
+//      return -1;
+//    {
+//      int i;
+//      for(i = 0; i < 10000; i++)
+//        yield();
+//    }
+void
+openiputtest(void)
+{
+  int pid;
+
+  printf(stdout, "openiput test\n");
+  if(mkdir("oidir") < 0){
+    printf(stdout, "mkdir oidir failed\n");
+    exit(0);
+  }
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "fork failed\n");
+    exit(0);
+  }
+  if(pid == 0){
+    int fd = open("oidir", O_RDWR);
+    if(fd >= 0){
+      printf(stdout, "open directory for write succeeded\n");
+      exit(0);
+    }
+    exit(0);
+  }
+  sleep(1);
+  if(unlink("oidir") != 0){
+    printf(stdout, "unlink failed\n");
+    exit(0);
+  }
+  wait(null);
+  printf(stdout, "openiput test ok\n");
+}
+
+// simple file system tests
+
+void
+opentest(void)
+{
+  int fd;
+
+  printf(stdout, "open test\n");
+  fd = open("echo", 0);
+  if(fd < 0){
+    printf(stdout, "open echo failed!\n");
+    exit(0);
+  }
+  close(fd);
+  fd = open("doesnotexist", 0);
+  if(fd >= 0){
+    printf(stdout, "open doesnotexist succeeded!\n");
+    exit(0);
+  }
+  printf(stdout, "open test ok\n");
+}
+
+void
+writetest(void)
+{
+  int fd;
+  int i;
+
+  printf(stdout, "small file test\n");
+  fd = open("small", O_CREATE|O_RDWR);
+  if(fd >= 0){
+    printf(stdout, "creat small succeeded; ok\n");
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit(0);
+  }
+  for(i = 0; i < 100; i++){
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+      printf(stdout, "error: write aa %d new file failed\n", i);
+      exit(0);
+    }
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+      printf(stdout, "error: write bb %d new file failed\n", i);
+      exit(0);
+    }
+  }
+  printf(stdout, "writes ok\n");
+  close(fd);
+  fd = open("small", O_RDONLY);
+  if(fd >= 0){
+    printf(stdout, "open small succeeded ok\n");
+  } else {
+    printf(stdout, "error: open small failed!\n");
+    exit(0);
+  }
+  i = read(fd, buf, 2000);
+  if(i == 2000){
+    printf(stdout, "read succeeded ok\n");
+  } else {
+    printf(stdout, "read failed\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(unlink("small") < 0){
+    printf(stdout, "unlink small failed\n");
+    exit(0);
+  }
+  printf(stdout, "small file test ok\n");
+}
+
+void
+writetest1(void)
+{
+  int i, fd, n;
+
+  printf(stdout, "big files test\n");
+
+  fd = open("big", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(stdout, "error: creat big failed!\n");
+    exit(0);
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+    ((int*)buf)[0] = i;
+    if(write(fd, buf, 512) != 512){
+      printf(stdout, "error: write big file failed\n", i);
+      exit(0);
+    }
+  }
+
+  close(fd);
+
+  fd = open("big", O_RDONLY);
+  if(fd < 0){
+    printf(stdout, "error: open big failed!\n");
+    exit(0);
+  }
+
+  n = 0;
+  for(;;){
+    i = read(fd, buf, 512);
+    if(i == 0){
+      if(n == MAXFILE - 1){
+        printf(stdout, "read only %d blocks from big", n);
+        exit(0);
+      }
+      break;
+    } else if(i != 512){
+      printf(stdout, "read failed %d\n", i);
+      exit(0);
+    }
+    if(((int*)buf)[0] != n){
+      printf(stdout, "read content of block %d is %d\n",
+             n, ((int*)buf)[0]);
+      exit(0);
+    }
+    n++;
+  }
+  close(fd);
+  if(unlink("big") < 0){
+    printf(stdout, "unlink big failed\n");
+    exit(0);
+  }
+  printf(stdout, "big files ok\n");
+}
+
+void
+createtest(void)
+{
+  int i, fd;
+
+  printf(stdout, "many creates, followed by unlink test\n");
+
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    fd = open(name, O_CREATE|O_RDWR);
+    close(fd);
+  }
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    unlink(name);
+  }
+  printf(stdout, "many creates, followed by unlink; ok\n");
+}
+
+void dirtest(void)
+{
+  printf(stdout, "mkdir test\n");
+
+  if(mkdir("dir0") < 0){
+    printf(stdout, "mkdir failed\n");
+    exit(0);
+  }
+
+  if(chdir("dir0") < 0){
+    printf(stdout, "chdir dir0 failed\n");
+    exit(0);
+  }
+
+  if(chdir("..") < 0){
+    printf(stdout, "chdir .. failed\n");
+    exit(0);
+  }
+
+  if(unlink("dir0") < 0){
+    printf(stdout, "unlink dir0 failed\n");
+    exit(0);
+  }
+  printf(stdout, "mkdir test ok\n");
+}
+
+void
+exectest(void)
+{
+  printf(stdout, "exec test\n");
+  if(exec("echo", echoargv) < 0){
+    printf(stdout, "exec echo failed\n");
+    exit(0);
+  }
+}
+
+// simple fork and pipe read/write
+
+void
+pipe1(void)
+{
+  int fds[2], pid;
+  int seq, i, n, cc, total;
+
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit(0);
+  }
+  pid = fork();
+  seq = 0;
+  if(pid == 0){
+    close(fds[0]);
+    for(n = 0; n < 5; n++){
+      for(i = 0; i < 1033; i++)
+        buf[i] = seq++;
+      if(write(fds[1], buf, 1033) != 1033){
+        printf(1, "pipe1 oops 1\n");
+        exit(0);
+      }
+    }
+    exit(0);
+  } else if(pid > 0){
+    close(fds[1]);
+    total = 0;
+    cc = 1;
+    while((n = read(fds[0], buf, cc)) > 0){
+      for(i = 0; i < n; i++){
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+          printf(1, "pipe1 oops 2\n");
+          return;
+        }
+      }
+      total += n;
+      cc = cc * 2;
+      if(cc > sizeof(buf))
+        cc = sizeof(buf);
+    }
+    if(total != 5 * 1033){
+      printf(1, "pipe1 oops 3 total %d\n", total);
+      exit(0);
+    }
+    close(fds[0]);
+    wait(null);
+  } else {
+    printf(1, "fork() failed\n");
+    exit(0);
+  }
+  printf(1, "pipe1 ok\n");
+}
+
+// meant to be run w/ at most two CPUs
+void
+preempt(void)
+{
+  int pid1, pid2, pid3;
+  int pfds[2];
+
+  printf(1, "preempt: ");
+  pid1 = fork();
+  if(pid1 == 0)
+    for(;;)
+      ;
+
+  pid2 = fork();
+  if(pid2 == 0)
+    for(;;)
+      ;
+
+  pipe(pfds);
+  pid3 = fork();
+  if(pid3 == 0){
+    close(pfds[0]);
+    if(write(pfds[1], "x", 1) != 1)
+      printf(1, "preempt write error");
+    close(pfds[1]);
+    for(;;)
+      ;
+  }
+
+  close(pfds[1]);
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+    printf(1, "preempt read error");
+    return;
+  }
+  close(pfds[0]);
+  printf(1, "kill... ");
+  kill(pid1);
+  kill(pid2);
+  kill(pid3);
+  printf(1, "wait... ");
+  wait(null);
+  wait(null);
+  wait(null);
+  printf(1, "preempt ok\n");
+}
+
+// try to find any races between exit and wait
+void
+exitwait(void)
+{
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      return;
+    }
+    if(pid){
+      if(wait(null) != pid){
+        printf(1, "wait wrong pid\n");
+        return;
+      }
+    } else {
+      exit(0);
+    }
+  }
+  printf(1, "exitwait ok\n");
+}
+
+void
+mem(void)
+{
+  void *m1, *m2;
+  int pid, ppid;
+
+  printf(1, "mem test\n");
+  ppid = getpid();
+  if((pid = fork()) == 0){
+    m1 = 0;
+    while((m2 = malloc(10001)) != 0){
+      *(char**)m2 = m1;
+      m1 = m2;
+    }
+    while(m1){
+      m2 = *(char**)m1;
+      free(m1);
+      m1 = m2;
+    }
+    m1 = malloc(1024*20);
+    if(m1 == 0){
+      printf(1, "couldn't allocate mem?!!\n");
+      kill(ppid);
+      exit(0);
+    }
+    free(m1);
+    printf(1, "mem ok\n");
+    exit(0);
+  } else {
+    wait(null);
+  }
+}
+
+// More file system tests
+
+// two processes write to the same file descriptor
+// is the offset shared? does inode locking work?
+void
+sharedfd(void)
+{
+  int fd, pid, i, n, nc, np;
+  char buf[10];
+
+  printf(1, "sharedfd test\n");
+
+  unlink("sharedfd");
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for writing");
+    return;
+  }
+  pid = fork();
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+  for(i = 0; i < 1000; i++){
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+      printf(1, "fstests: write sharedfd failed\n");
+      break;
+    }
+  }
+  if(pid == 0)
+    exit(0);
+  else
+    wait(null);
+  close(fd);
+  fd = open("sharedfd", 0);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    return;
+  }
+  nc = np = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i = 0; i < sizeof(buf); i++){
+      if(buf[i] == 'c')
+        nc++;
+      if(buf[i] == 'p')
+        np++;
+    }
+  }
+  close(fd);
+  unlink("sharedfd");
+  if(nc == 10000 && np == 10000){
+    printf(1, "sharedfd ok\n");
+  } else {
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+    exit(0);
+  }
+}
+
+// four processes write different files at the same
+// time, to test block allocation.
+void
+fourfiles(void)
+{
+  int fd, pid, i, j, n, total, pi;
+  char *names[] = { "f0", "f1", "f2", "f3" };
+  char *fname;
+
+  printf(1, "fourfiles test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    fname = names[pi];
+    unlink(fname);
+
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit(0);
+    }
+
+    if(pid == 0){
+      fd = open(fname, O_CREATE | O_RDWR);
+      if(fd < 0){
+        printf(1, "create failed\n");
+        exit(0);
+      }
+
+      memset(buf, '0'+pi, 512);
+      for(i = 0; i < 12; i++){
+        if((n = write(fd, buf, 500)) != 500){
+          printf(1, "write failed %d\n", n);
+          exit(0);
+        }
+      }
+      exit(0);
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    wait(null);
+  }
+
+  for(i = 0; i < 2; i++){
+    fname = names[i];
+    fd = open(fname, 0);
+    total = 0;
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+      for(j = 0; j < n; j++){
+        if(buf[j] != '0'+i){
+          printf(1, "wrong char\n");
+          exit(0);
+        }
+      }
+      total += n;
+    }
+    close(fd);
+    if(total != 12*500){
+      printf(1, "wrong length %d\n", total);
+      exit(0);
+    }
+    unlink(fname);
+  }
+
+  printf(1, "fourfiles ok\n");
+}
+
+// four processes create and delete different files in same directory
+void
+createdelete(void)
+{
+  enum { N = 20 };
+  int pid, i, fd, pi;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit(0);
+    }
+
+    if(pid == 0){
+      name[0] = 'p' + pi;
+      name[2] = '\0';
+      for(i = 0; i < N; i++){
+        name[1] = '0' + i;
+        fd = open(name, O_CREATE | O_RDWR);
+        if(fd < 0){
+          printf(1, "create failed\n");
+          exit(0);
+        }
+        close(fd);
+        if(i > 0 && (i % 2 ) == 0){
+          name[1] = '0' + (i / 2);
+          if(unlink(name) < 0){
+            printf(1, "unlink failed\n");
+            exit(0);
+          }
+        }
+      }
+      exit(0);
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    wait(null);
+  }
+
+  name[0] = name[1] = name[2] = 0;
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+      name[0] = 'p' + pi;
+      name[1] = '0' + i;
+      fd = open(name, 0);
+      if((i == 0 || i >= N/2) && fd < 0){
+        printf(1, "oops createdelete %s didn't exist\n", name);
+        exit(0);
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+        printf(1, "oops createdelete %s did exist\n", name);
+        exit(0);
+      }
+      if(fd >= 0)
+        close(fd);
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+      name[0] = 'p' + i;
+      name[1] = '0' + i;
+      unlink(name);
+    }
+  }
+
+  printf(1, "createdelete ok\n");
+}
+
+// can I unlink a file and still read it?
+void
+unlinkread(void)
+{
+  int fd, fd1;
+
+  printf(1, "unlinkread test\n");
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create unlinkread failed\n");
+    exit(0);
+  }
+  write(fd, "hello", 5);
+  close(fd);
+
+  fd = open("unlinkread", O_RDWR);
+  if(fd < 0){
+    printf(1, "open unlinkread failed\n");
+    exit(0);
+  }
+  if(unlink("unlinkread") != 0){
+    printf(1, "unlink unlinkread failed\n");
+    exit(0);
+  }
+
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+  write(fd1, "yyy", 3);
+  close(fd1);
+
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "unlinkread read failed");
+    exit(0);
+  }
+  if(buf[0] != 'h'){
+    printf(1, "unlinkread wrong data\n");
+    exit(0);
+  }
+  if(write(fd, buf, 10) != 10){
+    printf(1, "unlinkread write failed\n");
+    exit(0);
+  }
+  close(fd);
+  unlink("unlinkread");
+  printf(1, "unlinkread ok\n");
+}
+
+void
+linktest(void)
+{
+  int fd;
+
+  printf(1, "linktest\n");
+
+  unlink("lf1");
+  unlink("lf2");
+
+  fd = open("lf1", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "create lf1 failed\n");
+    exit(0);
+  }
+  if(write(fd, "hello", 5) != 5){
+    printf(1, "write lf1 failed\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(link("lf1", "lf2") < 0){
+    printf(1, "link lf1 lf2 failed\n");
+    exit(0);
+  }
+  unlink("lf1");
+
+  if(open("lf1", 0) >= 0){
+    printf(1, "unlinked lf1 but it is still there!\n");
+    exit(0);
+  }
+
+  fd = open("lf2", 0);
+  if(fd < 0){
+    printf(1, "open lf2 failed\n");
+    exit(0);
+  }
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "read lf2 failed\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(link("lf2", "lf2") >= 0){
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    exit(0);
+  }
+
+  unlink("lf2");
+  if(link("lf2", "lf1") >= 0){
+    printf(1, "link non-existant succeeded! oops\n");
+    exit(0);
+  }
+
+  if(link(".", "lf1") >= 0){
+    printf(1, "link . lf1 succeeded! oops\n");
+    exit(0);
+  }
+
+  printf(1, "linktest ok\n");
+}
+
+// test concurrent create/link/unlink of the same file
+void
+concreate(void)
+{
+  char file[3];
+  int i, pid, n, fd;
+  char fa[40];
+  struct {
+    ushort inum;
+    char name[14];
+  } de;
+
+  printf(1, "concreate test\n");
+  file[0] = 'C';
+  file[2] = '\0';
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    unlink(file);
+    pid = fork();
+    if(pid && (i % 3) == 1){
+      link("C0", file);
+    } else if(pid == 0 && (i % 5) == 1){
+      link("C0", file);
+    } else {
+      fd = open(file, O_CREATE | O_RDWR);
+      if(fd < 0){
+        printf(1, "concreate create %s failed\n", file);
+        exit(0);
+      }
+      close(fd);
+    }
+    if(pid == 0)
+      exit(0);
+    else
+      wait(null);
+  }
+
+  memset(fa, 0, sizeof(fa));
+  fd = open(".", 0);
+  n = 0;
+  while(read(fd, &de, sizeof(de)) > 0){
+    if(de.inum == 0)
+      continue;
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+      i = de.name[1] - '0';
+      if(i < 0 || i >= sizeof(fa)){
+        printf(1, "concreate weird file %s\n", de.name);
+        exit(0);
+      }
+      if(fa[i]){
+        printf(1, "concreate duplicate file %s\n", de.name);
+        exit(0);
+      }
+      fa[i] = 1;
+      n++;
+    }
+  }
+  close(fd);
+
+  if(n != 40){
+    printf(1, "concreate not enough files in directory listing\n");
+    exit(0);
+  }
+
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit(0);
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+       ((i % 3) == 1 && pid != 0)){
+      close(open(file, 0));
+      close(open(file, 0));
+      close(open(file, 0));
+      close(open(file, 0));
+    } else {
+      unlink(file);
+      unlink(file);
+      unlink(file);
+      unlink(file);
+    }
+    if(pid == 0)
+      exit(0);
+    else
+      wait(null);
+  }
+
+  printf(1, "concreate ok\n");
+}
+
+// another concurrent link/unlink/create test,
+// to look for deadlocks.
+void
+linkunlink()
+{
+  int pid, i;
+
+  printf(1, "linkunlink test\n");
+
+  unlink("x");
+  pid = fork();
+  if(pid < 0){
+    printf(1, "fork failed\n");
+    exit(0);
+  }
+
+  unsigned int x = (pid ? 1 : 97);
+  for(i = 0; i < 100; i++){
+    x = x * 1103515245 + 12345;
+    if((x % 3) == 0){
+      close(open("x", O_RDWR | O_CREATE));
+    } else if((x % 3) == 1){
+      link("cat", "x");
+    } else {
+      unlink("x");
+    }
+  }
+
+  if(pid)
+    wait(null);
+  else
+    exit(0);
+
+  printf(1, "linkunlink ok\n");
+}
+
+// directory that uses indirect blocks
+void
+bigdir(void)
+{
+  int i, fd;
+  char name[10];
+
+  printf(1, "bigdir test\n");
+  unlink("bd");
+
+  fd = open("bd", O_CREATE);
+  if(fd < 0){
+    printf(1, "bigdir create failed\n");
+    exit(0);
+  }
+  close(fd);
+
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(link("bd", name) != 0){
+      printf(1, "bigdir link failed\n");
+      exit(0);
+    }
+  }
+
+  unlink("bd");
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(unlink(name) != 0){
+      printf(1, "bigdir unlink failed");
+      exit(0);
+    }
+  }
+
+  printf(1, "bigdir ok\n");
+}
+
+void
+subdir(void)
+{
+  int fd, cc;
+
+  printf(1, "subdir test\n");
+
+  unlink("ff");
+  if(mkdir("dd") != 0){
+    printf(1, "subdir mkdir dd failed\n");
+    exit(0);
+  }
+
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/ff failed\n");
+    exit(0);
+  }
+  write(fd, "ff", 2);
+  close(fd);
+
+  if(unlink("dd") >= 0){
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    exit(0);
+  }
+
+  if(mkdir("/dd/dd") != 0){
+    printf(1, "subdir mkdir dd/dd failed\n");
+    exit(0);
+  }
+
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/dd/ff failed\n");
+    exit(0);
+  }
+  write(fd, "FF", 2);
+  close(fd);
+
+  fd = open("dd/dd/../ff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/../ff failed\n");
+    exit(0);
+  }
+  cc = read(fd, buf, sizeof(buf));
+  if(cc != 2 || buf[0] != 'f'){
+    printf(1, "dd/dd/../ff wrong content\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    exit(0);
+  }
+
+  if(unlink("dd/dd/ff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit(0);
+  }
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    exit(0);
+  }
+
+  if(chdir("dd") != 0){
+    printf(1, "chdir dd failed\n");
+    exit(0);
+  }
+  if(chdir("dd/../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit(0);
+  }
+  if(chdir("dd/../../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit(0);
+  }
+  if(chdir("./..") != 0){
+    printf(1, "chdir ./.. failed\n");
+    exit(0);
+  }
+
+  fd = open("dd/dd/ffff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/ffff failed\n");
+    exit(0);
+  }
+  if(read(fd, buf, sizeof(buf)) != 2){
+    printf(1, "read dd/dd/ffff wrong len\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    exit(0);
+  }
+
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/ff/ff succeeded!\n");
+    exit(0);
+  }
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/xx/ff succeeded!\n");
+    exit(0);
+  }
+  if(open("dd", O_CREATE) >= 0){
+    printf(1, "create dd succeeded!\n");
+    exit(0);
+  }
+  if(open("dd", O_RDWR) >= 0){
+    printf(1, "open dd rdwr succeeded!\n");
+    exit(0);
+  }
+  if(open("dd", O_WRONLY) >= 0){
+    printf(1, "open dd wronly succeeded!\n");
+    exit(0);
+  }
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    exit(0);
+  }
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    exit(0);
+  }
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    exit(0);
+  }
+  if(mkdir("dd/ff/ff") == 0){
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    exit(0);
+  }
+  if(mkdir("dd/xx/ff") == 0){
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    exit(0);
+  }
+  if(mkdir("dd/dd/ffff") == 0){
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    exit(0);
+  }
+  if(unlink("dd/xx/ff") == 0){
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    exit(0);
+  }
+  if(unlink("dd/ff/ff") == 0){
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    exit(0);
+  }
+  if(chdir("dd/ff") == 0){
+    printf(1, "chdir dd/ff succeeded!\n");
+    exit(0);
+  }
+  if(chdir("dd/xx") == 0){
+    printf(1, "chdir dd/xx succeeded!\n");
+    exit(0);
+  }
+
+  if(unlink("dd/dd/ffff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit(0);
+  }
+  if(unlink("dd/ff") != 0){
+    printf(1, "unlink dd/ff failed\n");
+    exit(0);
+  }
+  if(unlink("dd") == 0){
+    printf(1, "unlink non-empty dd succeeded!\n");
+    exit(0);
+  }
+  if(unlink("dd/dd") < 0){
+    printf(1, "unlink dd/dd failed\n");
+    exit(0);
+  }
+  if(unlink("dd") < 0){
+    printf(1, "unlink dd failed\n");
+    exit(0);
+  }
+
+  printf(1, "subdir ok\n");
+}
+
+// test writes that are larger than the log.
+void
+bigwrite(void)
+{
+  int fd, sz;
+
+  printf(1, "bigwrite test\n");
+
+  unlink("bigwrite");
+  for(sz = 499; sz < 12*512; sz += 471){
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    if(fd < 0){
+      printf(1, "cannot create bigwrite\n");
+      exit(0);
+    }
+    int i;
+    for(i = 0; i < 2; i++){
+      int cc = write(fd, buf, sz);
+      if(cc != sz){
+        printf(1, "write(%d) ret %d\n", sz, cc);
+        exit(0);
+      }
+    }
+    close(fd);
+    unlink("bigwrite");
+  }
+
+  printf(1, "bigwrite ok\n");
+}
+
+void
+bigfile(void)
+{
+  int fd, i, total, cc;
+
+  printf(1, "bigfile test\n");
+
+  unlink("bigfile");
+  fd = open("bigfile", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "cannot create bigfile");
+    exit(0);
+  }
+  for(i = 0; i < 20; i++){
+    memset(buf, i, 600);
+    if(write(fd, buf, 600) != 600){
+      printf(1, "write bigfile failed\n");
+      exit(0);
+    }
+  }
+  close(fd);
+
+  fd = open("bigfile", 0);
+  if(fd < 0){
+    printf(1, "cannot open bigfile\n");
+    exit(0);
+  }
+  total = 0;
+  for(i = 0; ; i++){
+    cc = read(fd, buf, 300);
+    if(cc < 0){
+      printf(1, "read bigfile failed\n");
+      exit(0);
+    }
+    if(cc == 0)
+      break;
+    if(cc != 300){
+      printf(1, "short read bigfile\n");
+      exit(0);
+    }
+    if(buf[0] != i/2 || buf[299] != i/2){
+      printf(1, "read bigfile wrong data\n");
+      exit(0);
+    }
+    total += cc;
+  }
+  close(fd);
+  if(total != 20*600){
+    printf(1, "read bigfile wrong total\n");
+    exit(0);
+  }
+  unlink("bigfile");
+
+  printf(1, "bigfile test ok\n");
+}
+
+void
+fourteen(void)
+{
+  int fd;
+
+  // DIRSIZ is 14.
+  printf(1, "fourteen test\n");
+
+  if(mkdir("12345678901234") != 0){
+    printf(1, "mkdir 12345678901234 failed\n");
+    exit(0);
+  }
+  if(mkdir("12345678901234/123456789012345") != 0){
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    exit(0);
+  }
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+  if(fd < 0){
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    exit(0);
+  }
+  close(fd);
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+  if(fd < 0){
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    exit(0);
+  }
+  close(fd);
+
+  if(mkdir("12345678901234/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    exit(0);
+  }
+  if(mkdir("123456789012345/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    exit(0);
+  }
+
+  printf(1, "fourteen ok\n");
+}
+
+void
+rmdot(void)
+{
+  printf(1, "rmdot test\n");
+  if(mkdir("dots") != 0){
+    printf(1, "mkdir dots failed\n");
+    exit(0);
+  }
+  if(chdir("dots") != 0){
+    printf(1, "chdir dots failed\n");
+    exit(0);
+  }
+  if(unlink(".") == 0){
+    printf(1, "rm . worked!\n");
+    exit(0);
+  }
+  if(unlink("..") == 0){
+    printf(1, "rm .. worked!\n");
+    exit(0);
+  }
+  if(chdir("/") != 0){
+    printf(1, "chdir / failed\n");
+    exit(0);
+  }
+  if(unlink("dots/.") == 0){
+    printf(1, "unlink dots/. worked!\n");
+    exit(0);
+  }
+  if(unlink("dots/..") == 0){
+    printf(1, "unlink dots/.. worked!\n");
+    exit(0);
+  }
+  if(unlink("dots") != 0){
+    printf(1, "unlink dots failed!\n");
+    exit(0);
+  }
+  printf(1, "rmdot ok\n");
+}
+
+void
+dirfile(void)
+{
+  int fd;
+
+  printf(1, "dir vs file\n");
+
+  fd = open("dirfile", O_CREATE);
+  if(fd < 0){
+    printf(1, "create dirfile failed\n");
+    exit(0);
+  }
+  close(fd);
+  if(chdir("dirfile") == 0){
+    printf(1, "chdir dirfile succeeded!\n");
+    exit(0);
+  }
+  fd = open("dirfile/xx", 0);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit(0);
+  }
+  fd = open("dirfile/xx", O_CREATE);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit(0);
+  }
+  if(mkdir("dirfile/xx") == 0){
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    exit(0);
+  }
+  if(unlink("dirfile/xx") == 0){
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    exit(0);
+  }
+  if(link("README", "dirfile/xx") == 0){
+    printf(1, "link to dirfile/xx succeeded!\n");
+    exit(0);
+  }
+  if(unlink("dirfile") != 0){
+    printf(1, "unlink dirfile failed!\n");
+    exit(0);
+  }
+
+  fd = open(".", O_RDWR);
+  if(fd >= 0){
+    printf(1, "open . for writing succeeded!\n");
+    exit(0);
+  }
+  fd = open(".", 0);
+  if(write(fd, "x", 1) > 0){
+    printf(1, "write . succeeded!\n");
+    exit(0);
+  }
+  close(fd);
+
+  printf(1, "dir vs file OK\n");
+}
+
+// test that iput() is called at the end of _namei()
+void
+iref(void)
+{
+  int i, fd;
+
+  printf(1, "empty file name\n");
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    if(mkdir("irefd") != 0){
+      printf(1, "mkdir irefd failed\n");
+      exit(0);
+    }
+    if(chdir("irefd") != 0){
+      printf(1, "chdir irefd failed\n");
+      exit(0);
+    }
+
+    mkdir("");
+    link("README", "");
+    fd = open("", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    fd = open("xx", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    unlink("xx");
+  }
+
+  chdir("/");
+  printf(1, "empty file name OK\n");
+}
+
+// test that fork fails gracefully
+// the forktest binary also does this, but it runs out of proc entries first.
+// inside the bigger usertests binary, we run out of memory first.
+void
+forktest(void)
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<1000; n++){
+    pid = fork();
+    if(pid < 0)
+      break;
+    if(pid == 0)
+      exit(0);
+  }
+
+  if(n == 1000){
+    printf(1, "fork claimed to work 1000 times!\n");
+    exit(0);
+  }
+
+  for(; n > 0; n--){
+    if(wait(null) < 0){
+      printf(1, "wait stopped early\n");
+      exit(0);
+    }
+  }
+
+  if(wait(null) != -1){
+    printf(1, "wait got too many\n");
+    exit(0);
+  }
+
+  printf(1, "fork test OK\n");
+}
+
+void
+sbrktest(void)
+{
+  int fds[2], pid, pids[10], ppid;
+  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  uint amt;
+
+  printf(stdout, "sbrk test\n");
+  oldbrk = sbrk(0);
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+  int i;
+  for(i = 0; i < 5000; i++){
+    b = sbrk(1);
+    if(b != a){
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+      exit(0);
+    }
+    *b = 1;
+    a = b + 1;
+  }
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "sbrk test fork failed\n");
+    exit(0);
+  }
+  c = sbrk(1);
+  c = sbrk(1);
+  if(c != a + 1){
+    printf(stdout, "sbrk test failed post-fork\n");
+    exit(0);
+  }
+  if(pid == 0)
+    exit(0);
+  wait(null);
+
+  // can one grow address space to something big?
+#define BIG (100*1024*1024)
+  a = sbrk(0);
+  amt = (BIG) - (uint)a;
+  p = sbrk(amt);
+  if (p != a) {
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    exit(0);
+  }
+  lastaddr = (char*) (BIG-1);
+  *lastaddr = 99;
+
+  // can one de-allocate?
+  a = sbrk(0);
+  c = sbrk(-4096);
+  if(c == (char*)0xffffffff){
+    printf(stdout, "sbrk could not deallocate\n");
+    exit(0);
+  }
+  c = sbrk(0);
+  if(c != a - 4096){
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    exit(0);
+  }
+
+  // can one re-allocate that page?
+  a = sbrk(0);
+  c = sbrk(4096);
+  if(c != a || sbrk(0) != a + 4096){
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    exit(0);
+  }
+  if(*lastaddr == 99){
+    // should be zero
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    exit(0);
+  }
+
+  a = sbrk(0);
+  c = sbrk(-(sbrk(0) - oldbrk));
+  if(c != a){
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    exit(0);
+  }
+
+  // can we read the kernel's memory?
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    ppid = getpid();
+    pid = fork();
+    if(pid < 0){
+      printf(stdout, "fork failed\n");
+      exit(0);
+    }
+    if(pid == 0){
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+      kill(ppid);
+      exit(0);
+    }
+    wait(null);
+  }
+
+  // if we run the system out of memory, does it clean up the last
+  // failed allocation?
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit(0);
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if((pids[i] = fork()) == 0){
+      // allocate a lot of memory
+      sbrk(BIG - (uint)sbrk(0));
+      write(fds[1], "x", 1);
+      // sit around until killed
+      for(;;) sleep(1000);
+    }
+    if(pids[i] != -1)
+      read(fds[0], &scratch, 1);
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if(pids[i] == -1)
+      continue;
+    kill(pids[i]);
+    wait(null);
+  }
+  if(c == (char*)0xffffffff){
+    printf(stdout, "failed sbrk leaked memory\n");
+    exit(0);
+  }
+
+  if(sbrk(0) > oldbrk)
+    sbrk(-(sbrk(0) - oldbrk));
+
+  printf(stdout, "sbrk test OK\n");
+}
+
+void
+validateint(int *p)
+{
+  int res;
+  asm("mov %%esp, %%ebx\n\t"
+      "mov %3, %%esp\n\t"
+      "int %2\n\t"
+      "mov %%ebx, %%esp" :
+      "=a" (res) :
+      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+      "ebx");
+}
+
+void
+validatetest(void)
+{
+  int hi, pid;
+  uint p;
+
+  printf(stdout, "validate test\n");
+  hi = 1100*1024;
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    if((pid = fork()) == 0){
+      // try to crash the kernel by passing in a badly placed integer
+      validateint((int*)p);
+      exit(0);
+    }
+    sleep(0);
+    sleep(0);
+    kill(pid);
+    wait(null);
+
+    // try to crash the kernel by passing in a bad string pointer
+    if(link("nosuchfile", (char*)p) != -1){
+      printf(stdout, "link should not succeed\n");
+      exit(0);
+    }
+  }
+
+  printf(stdout, "validate ok\n");
+}
+
+// does unintialized data start out zero?
+char uninit[10000];
+void
+bsstest(void)
+{
+  int i;
+
+  printf(stdout, "bss test\n");
+  for(i = 0; i < sizeof(uninit); i++){
+    if(uninit[i] != '\0'){
+      printf(stdout, "bss test failed\n");
+      exit(0);
+    }
+  }
+  printf(stdout, "bss test ok\n");
+}
+
+// does exec return an error if the arguments
+// are larger than a page? or does it write
+// below the stack and wreck the instructions/data?
+void
+bigargtest(void)
+{
+  int pid, fd;
+
+  unlink("bigarg-ok");
+  pid = fork();
+  if(pid == 0){
+    static char *args[MAXARG];
+    int i;
+    for(i = 0; i < MAXARG-1; i++)
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    args[MAXARG-1] = 0;
+    printf(stdout, "bigarg test\n");
+    exec("echo", args);
+    printf(stdout, "bigarg test ok\n");
+    fd = open("bigarg-ok", O_CREATE);
+    close(fd);
+    exit(0);
+  } else if(pid < 0){
+    printf(stdout, "bigargtest: fork failed\n");
+    exit(0);
+  }
+  wait(null);
+  fd = open("bigarg-ok", 0);
+  if(fd < 0){
+    printf(stdout, "bigarg test failed!\n");
+    exit(0);
+  }
+  close(fd);
+  unlink("bigarg-ok");
+}
+
+// what happens when the file system runs out of blocks?
+// answer: balloc panics, so this test is not useful.
+void
+fsfull()
+{
+  int nfiles;
+  int fsblocks = 0;
+
+  printf(1, "fsfull test\n");
+
+  for(nfiles = 0; ; nfiles++){
+    char name[64];
+    name[0] = 'f';
+    name[1] = '0' + nfiles / 1000;
+    name[2] = '0' + (nfiles % 1000) / 100;
+    name[3] = '0' + (nfiles % 100) / 10;
+    name[4] = '0' + (nfiles % 10);
+    name[5] = '\0';
+    printf(1, "writing %s\n", name);
+    int fd = open(name, O_CREATE|O_RDWR);
+    if(fd < 0){
+      printf(1, "open %s failed\n", name);
+      break;
+    }
+    int total = 0;
+    while(1){
+      int cc = write(fd, buf, 512);
+      if(cc < 512)
+        break;
+      total += cc;
+      fsblocks++;
+    }
+    printf(1, "wrote %d bytes\n", total);
+    close(fd);
+    if(total == 0)
+      break;
+  }
+
+  while(nfiles >= 0){
+    char name[64];
+    name[0] = 'f';
+    name[1] = '0' + nfiles / 1000;
+    name[2] = '0' + (nfiles % 1000) / 100;
+    name[3] = '0' + (nfiles % 100) / 10;
+    name[4] = '0' + (nfiles % 10);
+    name[5] = '\0';
+    unlink(name);
+    nfiles--;
+  }
+
+  printf(1, "fsfull test finished\n");
+}
+
+void
+uio()
+{
+  #define RTC_ADDR 0x70
+  #define RTC_DATA 0x71
+
+  ushort port = 0;
+  uchar val = 0;
+  int pid;
+
+  printf(1, "uio test\n");
+  pid = fork();
+  if(pid == 0){
+    port = RTC_ADDR;
+    val = 0x09;  /* year */
+    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    port = RTC_DATA;
+    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    printf(1, "uio: uio succeeded; test FAILED\n");
+    exit(0);
+  } else if(pid < 0){
+    printf (1, "fork failed\n");
+    exit(0);
+  }
+  wait(null);
+  printf(1, "uio test done\n");
+}
+
+void argptest()
+{
+  int fd;
+  fd = open("init", O_RDONLY);
+  if (fd < 0) {
+    printf(2, "open failed\n");
+    exit(0);
+  }
+  read(fd, sbrk(0) - 1, -1);
+  close(fd);
+  printf(1, "arg test passed\n");
+}
+
+unsigned long randstate = 1;
+unsigned int
+rand()
+{
+  randstate = randstate * 1664525 + 1013904223;
+  return randstate;
+}
+
+int
+main(int argc, char *argv[])
+{
+  printf(1, "usertests starting\n");
+
+  if(open("usertests.ran", 0) >= 0){
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    exit(0);
+  }
+  close(open("usertests.ran", O_CREATE));
+
+  argptest();
+  createdelete();
+  linkunlink();
+  concreate();
+  fourfiles();
+  sharedfd();
+
+  bigargtest();
+  bigwrite();
+  bigargtest();
+  bsstest();
+  sbrktest();
+  validatetest();
+
+  opentest();
+  writetest();
+  writetest1();
+  createtest();
+
+  openiputtest();
+  exitiputtest();
+  iputtest();
+
+  mem();
+  pipe1();
+  preempt();
+  exitwait();
+
+  rmdot();
+  fourteen();
+  bigfile();
+  subdir();
+  linktest();
+  unlinkread();
+  dirfile();
+  iref();
+  forktest();
+  bigdir(); // slow
+
+  uio();
+
+  exectest();
+
+  exit(0);
+}
diff --git a/Project_Test/include/ProjectTest.h b/Project_Test/include/ProjectTest.h
new file mode 100755
index 0000000..82cef67
--- /dev/null
+++ b/Project_Test/include/ProjectTest.h
@@ -0,0 +1,38 @@
+#ifndef PROJECT_TEST_H_
+#define PROJECT_TEST_H_
+
+#include <vector>
+#include <string>
+
+using std::vector;
+using std::string;
+
+// Declaring Extern Global Variables
+typedef void (*pointerToTestsFunctions)();
+extern vector<pointerToTestsFunctions> testsFunctions;
+extern int green;
+extern int red;
+extern int tests;
+extern const long MILLIS_TO_WAIT;
+extern pointerToTestsFunctions currentTestFunction;
+extern string currentTestName;
+extern vector<vector<string>> errorLog;
+extern bool testFunctionActive;
+
+// Declaring Functions
+void start();
+void * InitiateFunctionInThread(void * pVoid);
+void ExecuteTests();
+void summery();
+void test(int testId,string got, string expected,vector<string> args = vector<string>{""});
+void test(int testId,float got, float expected,vector<string> args = vector<string>{""});
+void test(int testId,int got, int expected,vector<string> args = vector<string>{""});
+void test(int testId,unsigned int got, unsigned int expected,vector<string> args = vector<string>{""});
+string GetStdoutFromCommand(string cmd);
+string GetStdoutFromCommandAsync(string cmd, string endCommandString,int maxMillisToWait,int & successFlag);
+FILE * popenGillespie(string command, string type, int & pid);
+int pcloseGillespie(FILE * fp, pid_t pid);
+pid_t popenMonitor(pid_t commandPID,int millisToWait);
+int pcloseMonitor(pid_t monitorPID);
+
+#endif
diff --git a/Project_Test/include/Tests.h b/Project_Test/include/Tests.h
new file mode 100755
index 0000000..777737f
--- /dev/null
+++ b/Project_Test/include/Tests.h
@@ -0,0 +1,28 @@
+#ifndef TESTS_H_
+#define TESTS_H_
+
+#include <vector>
+#include <complex>
+#include <string>
+
+using std::string;
+using std::vector;
+using std::complex;
+
+// Declaring Functions
+void InitializingTests();
+void Initialize();
+void Finialize();
+bool procceseTest(string testFile,unsigned int testNumber);
+unsigned int CreateTests();
+void sigintHandler(int num);
+void Operating_System_Test();
+string processTestOutput(string output);
+string processCompareString(string str);
+void createXV6_TestMakefile(string makefilePath,vector<string> userspacePrograms);
+string processAppendMakefileUPROGS(vector<string> append);
+string replaceInString(string str,char toReplace,string replaceWith);
+int countSubStr(string str,string findSubStr);
+void runSpecificTest(int testToExecute);
+
+#endif
diff --git a/Project_Test/makefile b/Project_Test/makefile
new file mode 100755
index 0000000..7c16b8a
--- /dev/null
+++ b/Project_Test/makefile
@@ -0,0 +1,31 @@
+# All Targets
+all: start
+
+# Tool invocations
+# Executable "start" depends on the files ProjectTest.o and Tests.o.
+start: bin/ProjectTest.o bin/Tests.o
+	@echo 'Building target: start'
+	@echo 'Invoking: C++ Linker'
+	g++ -pthread -o bin/start bin/ProjectTest.o bin/Tests.o
+	@echo 'Finished building target: start'
+	@echo 'Executing Project Test'
+	reset
+	bin/start $(ARGS)
+	rm -f bin/*
+
+gdb: bin/ProjectTest.o bin/Tests.o
+	g++ -pthread -o bin/start bin/ProjectTest.o bin/Tests.o
+	gdb bin/start 
+	rm -f bin/* 
+	
+# Depends on the source and header files
+bin/ProjectTest.o: src/ProjectTest.cpp
+	g++ -g -Wall -Weffc++ -std=c++11 -c -Iinclude -o bin/ProjectTest.o src/ProjectTest.cpp
+
+# Depends on the source and header files
+bin/Tests.o: src/Tests.cpp
+	g++ -g -Wall -Weffc++ -std=c++11 -c -Iinclude -o bin/Tests.o src/Tests.cpp
+
+#Clean the build directory
+clean:
+	rm -f bin/*
diff --git a/Project_Test/src/ProjectTest.cpp b/Project_Test/src/ProjectTest.cpp
new file mode 100755
index 0000000..3a48a4d
--- /dev/null
+++ b/Project_Test/src/ProjectTest.cpp
@@ -0,0 +1,505 @@
+// Using Code from Author: Jeremy Morgan
+
+#include <vector>
+#include <string>
+#include <iostream>
+#include <pthread.h>
+#include <chrono>
+#include <thread>
+#include <time.h>
+#include "../include/ProjectTest.h"
+#include "../include/Tests.h"
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <sstream>
+#include <chrono>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+using std::vector;
+using std::string;
+using std::cout;
+using std::clock;
+using std::endl;
+using std::to_string;
+
+#define RED   "\e[38;5;196m"
+#define GRN   "\e[38;5;082m"
+#define YEL   "\e[38;5;226m"
+#define MAG   "\e[38;5;201m"
+#define ORG   "\e[38;5;202m"
+#define RESET "\e[0m"
+
+// Defining Global Variables
+int green = 0;
+int red = 0;
+int tests;
+const long MILLIS_TO_WAIT = 6000000;
+int timeForSmallTest = 600000;
+vector<pointerToTestsFunctions> testsFunctions;
+pointerToTestsFunctions currentTestFunction = 0;
+string currentTestName = "NO_TEST_HAS_BEEN_SUCCESSFULLY_EXECUTED_YET";
+vector<vector<string>> errorLog;
+bool testFunctionActive = 0;
+int testToExecute = -1;
+
+int main(int argc,char* argv[])
+{
+    // Retrieving args
+    if(argc == 2){
+        // Retrieving specific test to execute
+        int number;
+        if((number = atoi(argv[1]))){
+            testToExecute = number;
+        }
+    }
+
+    // Starting tests
+    start();
+
+    // Initializing tests to be executed
+    InitializingTests();
+
+    // Initializing before execution of tests
+    Initialize();
+
+    // Executing tests
+    ExecuteTests();
+
+    // Finialize after execution of tests
+    Finialize();
+    
+    // Summarizing tests
+    summery();
+}
+
+// Declaring start of test
+void start()
+{
+    // Declaring start of test
+    cout << MAG << "*******************************************" << endl;
+    cout << "       Start Of Operating System Test                  " << endl;
+    cout << "*******************************************\n" << RESET << endl;
+
+}
+
+// Executing tests
+void ExecuteTests()
+{
+    // Initializing
+    int rc;
+
+    // Executing tests
+    for(unsigned int i = 0;i < testsFunctions.size();i++)
+    {
+      // Executing Thread
+      pthread_t thread;
+      currentTestFunction = testsFunctions.at(i);
+      rc = pthread_create(&thread, NULL, InitiateFunctionInThread,NULL);
+
+      // Asserting Thread Was Successfully Executed
+      if (rc)
+      {
+        cout << "\n\n\n----------------------------\nError:unable to create thread"
+             << "\n----------------------------\n\n\n" << rc << endl;
+
+        continue;
+      }
+
+      // Waiting For Thread To Finish  -->
+
+      //Retrieving Current Time For Timeout
+      std::this_thread::sleep_for(std::chrono::milliseconds(200));
+      auto t_start = std::chrono::high_resolution_clock::now();
+
+      // Waiting For Current Test To Finish Unless Timeout
+      while (testFunctionActive == 1)
+      {
+        // Retrieving Current Time For Timeout
+        auto t_end = std::chrono::high_resolution_clock::now();
+
+        // Calculating Current Test Duration
+        float duration = std::chrono::duration<double, std::milli>(t_end-t_start).count();
+
+        // Asserting Test Duration Did Not Pass Limit
+        if(duration > MILLIS_TO_WAIT)
+        {
+          // Canceling Thread
+          pthread_cancel(thread);
+
+          // Declaring Test Execution Ended With TImeout
+          test(-1,"$$$ TEST EXECUTION TIMED OUT $$$","");
+
+          // Declaring test terminated
+          testFunctionActive = 0;
+        }
+      }
+    }
+      // Waiting For Thread To Finish  <--
+}
+
+void * InitiateFunctionInThread(void * pVoid)
+{
+    // Declaring Test Thread Active
+    testFunctionActive = 1;
+
+    // Executing Test Function
+    try
+    {
+      currentTestFunction();
+    }
+    catch(const std::exception &exc)
+    { 
+      // Adding error to error log
+      vector<string> newError;
+      newError.push_back(currentTestName);
+      newError.push_back(exc.what());
+      errorLog.push_back(newError);
+
+      // Declaring Exception Raised Durning Test Execution
+      test(-1,"","$$$ DECLARE BAD TEST $$$");
+    }
+
+    // Declaring Test Thread No Longer Active
+    testFunctionActive = 0;
+
+    // Exiting Thread
+    pthread_exit(NULL);
+}
+
+void summery()
+{
+    // Declaring end of test
+    cout << MAG << "\n*******************************************" << endl;
+    cout << "       End Of Operating System Test                    " << endl;
+    cout << "*******************************************" << RESET << endl;
+
+    // Summarizing
+    cout << GRN << "Green: " <<  green << RESET <<  "," << RED << " Red: " << red << RESET << endl;
+
+    // Printing exceptions log
+    if(errorLog.size() != 0)
+    {
+        cout << "\nExceptions Log:\n-------------------------------------------" << endl;
+
+
+        for (unsigned int i = 0;i < errorLog.size();i++)
+          cout << "\n" <<  errorLog[i][0] << " exceptions log:\n" << errorLog[i][1];
+    }
+}
+
+// Checking if test operated according to plan
+void test(int testId,string got, string expected,vector<string> args)
+{
+    // Initializing
+    bool testPassed = false;
+
+    // Counting test
+    tests++;
+
+    // Calculating test results
+    if(expected == "$$$ ASSERT_THROWN_EXCEPTIONS $$$")
+    {
+      testPassed = false;
+      got = "$$$ NO EXCEPTION WAS THROWN $$$";
+    }
+    else if(expected == "$$$ ASSERT_NO_THROWN_EXCEPTIONS $$$" || expected == "$$$ DECLARE GOOD TEST $$$" || got == expected)
+      testPassed = true;
+    else if(expected == "$$$ DECLARE BAD TEST $$$")
+    {
+      testPassed = false;
+      got = "$$$ EXCEPTION WAS THROWN $$$";
+    }
+    else if(expected == "$$$ TEST EXECUTION TIMED OUT $$$")
+      testPassed = false;
+    else if(expected == "$$$ SMALL TEST EXECUTION TIMED OUT $$$")
+      testPassed = false;
+    else if(expected == "$$$ TEST EXECUTION ERROR $$$")
+      testPassed = false;
+
+ // Checking if test operated according to plan
+    if (testPassed == true)
+    {
+      // Counting good test
+      green++;
+    }
+    else
+    {
+      // Counting bad test and declaring
+      red++;
+
+      // Declaring bad test
+      if(got == "$$$ EXCEPTION WAS THROWN $$$")
+        cout << RED << currentTestName <<  "(Test ID: " << testId << ")" <<
+             " did not complete successfully !!!\n" << RESET;
+      else if(got == "$$$ TEST EXECUTION TIMED OUT $$$")
+        cout << RED << currentTestName <<  "(Test ID: " << testId << ")" <<
+             " took more than " <<  MILLIS_TO_WAIT/1000 << " seconds, therefore it has been timed out.\n"
+             << RESET;
+      else if(got == "$$$ SMALL TEST EXECUTION TIMED OUT $$$")
+        cout << RED << currentTestName <<  "(Test ID: " << testId << ")" <<
+             " took more than " <<  timeForSmallTest/1000 << " seconds, therefore it has been timed out.\n"
+             << RESET;
+      else if(got == "$$$ TEST EXECUTION ERROR $$$")
+        cout << RED << currentTestName <<  "(Test ID: " << testId << ")" <<
+             " ennded with fatal error, see test output for more information.\n"
+             << RESET;
+      else if(args[0] == "String value with /n")
+        cout << RED << currentTestName <<  "(Test ID: " << testId << ")" <<
+             " --> Failed" << ",\n-------------------------------\ngot\n-------------------------------\n" <<
+             YEL << got << RED <<
+             "\n-------------------------------\nwhile expected\n-------------------------------\n" << GRN
+             << expected << RED
+             "\n-------------------------------\n" << RESET;
+      else
+        cout << RED <<  currentTestName <<  "(Test ID: " << testId << ")" <<  " --> Failed" <<
+             ", got " << YEL << got << RED << " while expected " << GRN << expected << RED << ".\n" << RESET;
+
+      if(args.size() >= 2 && args[1] != ""){
+          cout << ORG << "hint: " << args[1] << "\n" <<  RESET;
+      }
+    }
+}
+
+// Checking if test operated according to plan
+void test(int testId,float got, float expected,vector<string> args)
+{
+    test(testId,to_string(got),to_string(expected),args);
+}
+
+void test(int testId,int got, int expected,vector<string> args)
+{
+    test(testId,to_string(got),to_string(expected),args);
+}
+
+void test(int testId,unsigned int got, unsigned int expected,vector<string> args)
+{
+    test(testId,to_string(got),to_string(expected),args);
+}
+
+// Retrieving Terminal Output :: Author: Jeremy Morgan
+string GetStdoutFromCommand(string cmd)
+{
+  // Initializing
+  string data;
+  FILE * stream;
+  const int max_buffer = 4000;
+  char buffer[max_buffer];
+  cmd.append(" 2>&1");
+  stream = popen(cmd.c_str(), "r");
+  
+  // Retrieving Terminal Output
+  if (stream)
+  {
+      while (!feof(stream))
+      {
+        if (fgets(buffer, max_buffer, stream) != NULL)
+          data.append(buffer);
+      }
+
+      pclose(stream);
+  }
+
+  return data;
+}
+
+// Retrieving Terminal Output Async :: Author: Jeremy Morgan
+string GetStdoutFromCommandAsync(string cmd, string endCommandString,int maxMillisToWait,int & successFlag)
+{
+
+  // Initializing
+  string data;
+  const int max_buffer = 4000;
+  char buffer[max_buffer];
+  FILE * stream;
+  cmd.append(" 2>&1");
+  pid_t commandPID;
+  bool testEnded = false;
+  pid_t monitorPID;
+  successFlag = false;
+  int monitorStatus;
+
+  // Executing command
+  stream = popenGillespie(cmd.c_str(), "r",commandPID);
+
+  // Retrieving monitor for command
+  monitorPID = popenMonitor(commandPID,maxMillisToWait);
+
+  // Retrieving Terminal Output
+  if (stream)
+  {   
+     while (!feof(stream))
+      { 
+        // Reading line of test output
+        if (fgets(buffer, max_buffer, stream) != NULL){
+            data.append(buffer);
+            string bufferString(buffer);
+
+            // Checking for test end condition
+            if(bufferString.find(endCommandString) != string::npos){
+              testEnded = true;
+            }
+        }
+
+        // Ending command if needed
+        if(testEnded){
+          kill(-commandPID, 9);
+          break;
+        }
+      }
+  }
+
+  // Closing stream
+  pcloseGillespie(stream,commandPID);
+
+  // Closing monitor
+  monitorStatus = pcloseMonitor(monitorPID);
+
+  // Declaring test completed or not
+  if(testEnded){
+    successFlag = 1;
+  }
+  else if(monitorStatus == 1){
+    successFlag = 0;
+  }
+  else{
+    successFlag = -1;
+  }
+
+  return data;
+}
+
+#define READ   0
+#define WRITE  1
+
+// Gillespie code for popen with pid extract
+FILE * popenGillespie(string command, string type, int & pid)
+{
+    pid_t child_pid;
+    int fd[2];
+    pipe(fd);
+
+    if((child_pid = fork()) == -1)
+    {
+        perror("fork");
+        exit(1);
+    }
+
+    /* child process */
+    if (child_pid == 0)
+    {
+        if (type == "r")
+        {
+            close(fd[READ]);    //Close the READ end of the pipe since the child's fd is write-only
+            dup2(fd[WRITE], 1); //Redirect stdout to pipe
+        }
+        else
+        {
+            close(fd[WRITE]);    //Close the WRITE end of the pipe since the child's fd is read-only
+            dup2(fd[READ], 0);   //Redirect stdin to pipe
+        }
+
+        setpgid(child_pid, child_pid); //Needed so negative PIDs can kill children of /bin/sh
+        execl("/bin/sh", "/bin/sh", "-c", command.c_str(), NULL);
+        exit(0);
+    }
+    else
+    {
+        if (type == "r")
+        {
+            close(fd[WRITE]); //Close the WRITE end of the pipe since parent's fd is read-only
+        }
+        else
+        {
+            close(fd[READ]); //Close the READ end of the pipe since parent's fd is write-only
+        }
+    }
+
+    pid = child_pid;
+
+    if (type == "r")
+    {
+        return fdopen(fd[READ], "r");
+    }
+
+    return fdopen(fd[WRITE], "w");
+}
+
+// Gillespie code for pclose with pid extract
+int pcloseGillespie(FILE * fp, pid_t pid)
+{
+    int stat;
+
+    fclose(fp);
+    while (waitpid(pid, &stat, 0) == -1)
+    {
+        if (errno != EINTR)
+        {
+            stat = -1;
+            break;
+        }
+    }
+
+    return stat;
+}
+
+// Opening monitor for ending test if time runs out
+pid_t popenMonitor(pid_t commandPID,int millisToWait)
+{
+    pid_t child_pid;
+
+    if((child_pid = fork()) == -1)
+    {
+        perror("fork");
+        exit(1);
+    }
+
+    /* child process */
+    if (child_pid == 0)
+    {   
+        // Catching signal and ignoring it so that wont wake up from sleep
+        signal(SIGINT,SIG_IGN);
+
+        // Waiting for command to finish
+        std::this_thread::sleep_for(std::chrono::milliseconds(millisToWait));
+
+        // Ending command
+        kill(-commandPID, 9);
+
+        // Exiting
+        exit(0);
+    }
+
+    return child_pid;
+}
+
+// Gillespie code for pclose with pid extract
+int pcloseMonitor(pid_t monitorPID)
+{   
+    // Initializing
+    int monitorStatus;
+    int returnStatus;
+
+    // Checking if monitor has exited
+    waitpid(monitorPID,&monitorStatus,WNOHANG);
+    
+    // Ending monitor
+    kill(monitorPID, 9);
+
+    // Checking if monitor exited normally or was forced exit
+    if(WIFEXITED(monitorStatus)){
+      returnStatus =  1;
+    }
+    else{
+      returnStatus =  -1;
+    }
+
+    return returnStatus;
+}
\ No newline at end of file
diff --git a/Project_Test/src/Tests.cpp b/Project_Test/src/Tests.cpp
new file mode 100755
index 0000000..72040aa
--- /dev/null
+++ b/Project_Test/src/Tests.cpp
@@ -0,0 +1,1211 @@
+#include "../include/Tests.h"
+#include "../include/ProjectTest.h"
+#include <iostream>
+#include <typeinfo>
+#include <fstream>
+#include <math.h>
+#include <sstream>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+#include <vector>
+
+using std::vector;
+using std::streambuf;
+using std::istringstream;
+using std::to_string;
+using std::cout;
+using std::sprintf;
+using std::complex;
+using std::ifstream;
+using std::stringstream;
+
+#define RED   "\e[38;5;196m"
+#define GRN   "\e[38;5;082m"
+#define YEL   "\e[38;5;226m"
+#define MAG   "\e[38;5;201m"
+#define RESET "\e[0m"
+
+// Defining Global Variables
+vector<string> testsInputs;
+vector<string> testsExpected;
+vector<vector<string>> testsUserPrograms;
+vector<string> testsHints;
+
+std::stringstream ss;
+std::streambuf *old_buf;
+int abortExecution = 0;
+extern int timeForSmallTest;
+extern int testToExecute;
+
+// Initializing before execution of tests
+void Initialize()
+{ 
+  //change the underlying cout buffer and save the old buffer
+  old_buf = std::cout.rdbuf(ss.rdbuf());
+
+  // Catching signal
+  signal(SIGINT,sigintHandler);
+}
+
+// Finialize after execution of tests
+void Finialize()
+{   
+    // Restoring signal behaviour
+    signal(SIGINT,SIG_DFL);
+
+    // Restoring cout buffer
+    std::cout.rdbuf(old_buf);
+
+    // Printing cout output
+    std::string text_output = ss.str();
+    std::cout << text_output;
+}
+
+// Initializing tests to be executed
+void InitializingTests()
+{
+    /* ### Example of use ###
+
+     testsFunctions.push_back();
+
+    */
+
+    // Initializing tests to be executed
+    testsFunctions.push_back(Operating_System_Test);
+
+    // Defining tests
+    string test_0_Input = R"V0G0N(
+usertests
+)V0G0N";
+    string test_0_Expected = "#ALL TESTS PASSED"; 
+    vector<string> test_0_UserPrograms = {"usertests","quitXV6"};
+    string test_0_Hint = "General problem with xv6 due to changes made to it."; 
+
+    string test_1_Input = R"V0G0N(
+forktest
+    )V0G0N";
+    string test_1_Expected = R"V0G0N(
+$ fork test
+fork test OK
+$ $ Finished Yehonatan Peleg Test, quiting...
+)V0G0N";
+    vector<string> test_1_UserPrograms = {"quitXV6"};
+    string test_1_Hint = "General problem with xv6 due to changes made to it.";
+
+    string test_2_Input = R"V0G0N(
+pathTest
+helloW
+pathTest1
+helloW
+pathTest2.1
+helloW
+pathTest2.2
+helloW
+pathTest3
+helloW
+    )V0G0N";
+    string test_2_Expected = "+3Hello World XV6";
+    vector<string> test_2_UserPrograms = {"helloW","pathTest","pathTest1","quitXV6",
+                                          "pathTest2.1","pathTest2.2","pathTest3"};
+    string test_2_Hint = "Problem with the implementation of task1: Path environment variable.";
+
+    string test_3_Input = R"V0G0N(
+exitWait
+    )V0G0N";
+    string test_3_Expected = R"V0G0N(
+$ 1 child exit status is: 1
+2 child exit status is: 2
+3 child exit status is: 3
+4 child exit status is: 4
+5 child exit status is: 5
+6 child exit status is: 6
+7 child exit status is unknown
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_3_UserPrograms = {"exitWait","detachTest","quitXV6"};
+    string test_3_Hint = "Problem with the implementation of task2: Exit and wait do not funtion properly.";
+
+    string test_4_Input = R"V0G0N(
+detachTest
+    )V0G0N";
+    string test_4_Expected = R"V0G0N(
+$ detach result for not my child is: -1
+detach result for child 1 is: 0
+detach result for child 2 is: 0
+detach result for child 3 is: 0
+detach result for child 4 is: 0
+detach result for child 5 is: 0
+detach result for child 6 is: 0
+detach result for not my child is: -1
+second detach result for child 1 is: -1
+second detach result for child 2 is: -1
+second detach result for child 3 is: -1
+second detach result for child 4 is: -1
+second detach result for child 5 is: -1
+second detach result for child 6 is: -1
+detach result for not my child is: -1
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+no child left to wait for
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_4_UserPrograms = {"exitWait","detachTest","quitXV6"};
+    string test_4_Hint = "Problem with the implementation of task2: Detach do not funtion properly.";
+
+    string test_5_Input = R"V0G0N(
+prioritySysTest
+policySysTest
+    )V0G0N";
+    string test_5_Expected = R"V0G0N(
+$ Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with correct args
+Calling priority system call with wrong args
+Calling priority system call with wrong args
+Calling priority system call with wrong args
+$ Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling priority system call with correct args
+Calling policy system call
+Calling policy system call
+Calling priority system call with correct args
+Calling priority system call with wrong args
+Calling policy system call
+Calling priority system call with wrong args
+Calling policy system call
+Calling priority system call with wrong args
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_5_UserPrograms = {"prioritySysTest","policySysTest","quitXV6"};
+    string test_5_Hint = "Problem with the implementation of task3: Priority or policy sys calls maybe crushes.";
+
+    string test_6_Input = R"V0G0N(
+schedulingTest1
+    )V0G0N";
+    string test_6_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_6_UserPrograms = {"schedulingTest1","quitXV6"};
+    string test_6_Hint = "Problem with the implementation of task3: Round Robin do not function properly. "
+                         " Maybe you forgot to insert a process to the queue after been killed.";
+
+    string test_7_Input = R"V0G0N(
+schedulingTest2
+    )V0G0N";
+    string test_7_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_7_UserPrograms = {"schedulingTest2","quitXV6"};
+    string test_7_Hint = "Problem with the implementation of task3: Priority Scheduling do not function properly. "
+                         " Maybe you forgot to insert a process to the queue after been killed.";
+
+    string test_8_Input = R"V0G0N(
+schedulingTest3
+    )V0G0N";
+    string test_8_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_8_UserPrograms = {"schedulingTest3","quitXV6"};
+    string test_8_Hint = "Problem with the implementation of task3: Extendedn Priority Scheduling do not function properly. "
+                         " Maybe you forgot to insert a process to the queue after been killed.";
+
+    string test_9_Input = R"V0G0N(
+schedulingTest4
+    )V0G0N";
+    string test_9_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_9_UserPrograms = {"schedulingTest4","quitXV6"};
+    string test_9_Hint = "Problem with the implementation of task3: Switching between scheduling policies do not function properly.";
+
+    string test_10_Input = R"V0G0N(
+schedulingTest5
+    )V0G0N";
+    string test_10_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_10_UserPrograms = {"schedulingTest5","quitXV6"};
+    string test_10_Hint = "Problem with the implementation of task3: Switching between scheduling policies do not function properly.";
+
+    string test_11_Input = R"V0G0N(
+schedulingTest6
+    )V0G0N";
+    string test_11_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 30000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_11_UserPrograms = {"schedulingTest6","quitXV6"};
+    string test_11_Hint = "Problem with the implementation of task3: Switching between scheduling policies do not function properly.";
+
+    string test_12_Input = R"V0G0N(
+schedulingTest7
+    )V0G0N";
+    string test_12_Expected = R"V0G0N(
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_12_UserPrograms = {"schedulingTest7","quitXV6"};
+    string test_12_Hint = "Problem with the implementation of task3: Priorites In Priority Scheduling do not function properly.";
+
+    string test_13_Input = R"V0G0N(
+schedulingTest8
+    )V0G0N";
+    string test_13_Expected = R"V0G0N(
+$ 11111111119999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_13_UserPrograms = {"schedulingTest8","quitXV6"};
+    string test_13_Hint = "Problem with the implementation of task3: Priorites In Extended Priority Scheduling do not function properly.";
+
+    string test_14_Input = R"V0G0N(
+schedulingTest9
+    )V0G0N";
+    string test_14_Expected = R"V0G0N(
+$ 00000000009999999999
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_14_UserPrograms = {"schedulingTest9","quitXV6"};
+    string test_14_Hint = "Problem with the implementation of task3: Priorites In Extended Priority Scheduling do not function properly.";
+
+    string test_15_Input = R"V0G0N(
+schedulingTest10
+    )V0G0N";
+    string test_15_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_15_UserPrograms = {"schedulingTest10","quitXV6"};
+    string test_15_Hint = "Problem with the implementation of task3: Starvation In Extended Priority Scheduling.";
+
+    string test_16_Input = R"V0G0N(
+schedulingTest11
+    )V0G0N";
+    string test_16_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_16_UserPrograms = {"schedulingTest11","quitXV6"};
+    string test_16_Hint = "Problem with the implementation of task3: Starvation In Priority Scheduling."
+                          " Maybe you let setting priority 0 when priority 2 is selected.";
+
+    string test_17_Input = R"V0G0N(
+schedulingTest12
+    )V0G0N";
+    string test_17_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 15000 time quantums !!!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+zombie!
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";;
+    vector<string> test_17_UserPrograms = {"schedulingTest12","quitXV6"};
+    string test_17_Hint = "Problem with the implementation of task3: Starvation In Priority Scheduling."
+                          " Maybe you forgot to set priority to 1 of all priority 0 processes when switching from policy 3 to 2.";
+
+    string test_18_Input = R"V0G0N(
+schedulingTest13
+    )V0G0N";
+    string test_18_Expected = R"V0G0N(
+$ Initiating scheduling test, test should take approximately 10000 time quantums !!!
+ctime test 1 ok
+ctime test 2 ok
+ctime test 3 ok
+ctime test 4 ok
+ctime test 5 ok
+stime test 1 ok
+stime test 2 ok
+stime test 3 ok
+stime test 4 ok
+stime test 5 ok
+rutime test 1 ok
+rutime test 2 ok
+rutime test 3 ok
+rutime test 4 ok
+rutime test 5 ok
+ttime test 1 ok
+ttime test 2 ok
+ttime test 3 ok
+ttime test 4 ok
+ttime test 5 ok
+ttime test 6 ok
+ttime test 7 ok
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";
+    vector<string> test_18_UserPrograms = {"schedulingTest13","quitXV6"};
+    string test_18_Hint = "Problem with the implementation of task3: Problem with the implementation of the performance data capture.";
+
+    string test_19_Input = R"V0G0N(
+pathTest
+pathTest4
+echo Hello_World_XV6 | cat
+pathTest5
+echo Hello_World_XV6 | cat
+    )V0G0N";
+    string test_19_Expected = "+1Hello_World_XV6";
+    vector<string> test_19_UserPrograms = {"pathTest","pathTest4","pathTest5","quitXV6"};
+    string test_19_Hint = "Problem with the implementation of task1: Path environment variable with pipes.";
+
+    string test_20_Input = R"V0G0N(
+policy 1
+echo "policy 1"
+policy 3
+echo "policy 3"
+policy 2
+echo "policy 2"
+    )V0G0N";
+    string test_20_Expected = R"V0G0N(
+$ $ "policy 1"
+$ $ "policy 3"
+$ $ "policy 2"
+$ $ Finished Yehonatan Peleg Test, quiting...
+    )V0G0N";
+    vector<string> test_20_UserPrograms = {"quitXV6"};
+    string test_20_Hint = "Problem with the implementation of task3: User program policy dosen't work.";
+
+    // Adding Tests inputs and expected
+    testsInputs.push_back(test_0_Input);
+    testsExpected.push_back(test_0_Expected);
+    testsUserPrograms.push_back(test_0_UserPrograms);
+    testsHints.push_back(test_0_Hint);
+
+    testsInputs.push_back(test_1_Input);
+    testsExpected.push_back(test_1_Expected);
+    testsUserPrograms.push_back(test_1_UserPrograms);
+    testsHints.push_back(test_1_Hint);
+
+    testsInputs.push_back(test_2_Input);
+    testsExpected.push_back(test_2_Expected);
+    testsUserPrograms.push_back(test_2_UserPrograms);
+    testsHints.push_back(test_2_Hint);
+
+    testsInputs.push_back(test_3_Input);
+    testsExpected.push_back(test_3_Expected);
+    testsUserPrograms.push_back(test_3_UserPrograms);
+    testsHints.push_back(test_3_Hint);
+
+    testsInputs.push_back(test_4_Input);
+    testsExpected.push_back(test_4_Expected);
+    testsUserPrograms.push_back(test_4_UserPrograms);
+    testsHints.push_back(test_4_Hint);
+
+    testsInputs.push_back(test_5_Input);
+    testsExpected.push_back(test_5_Expected);
+    testsUserPrograms.push_back(test_5_UserPrograms);
+    testsHints.push_back(test_5_Hint);
+
+    testsInputs.push_back(test_6_Input);
+    testsExpected.push_back(test_6_Expected);
+    testsUserPrograms.push_back(test_6_UserPrograms);
+    testsHints.push_back(test_6_Hint);
+
+    testsInputs.push_back(test_7_Input);
+    testsExpected.push_back(test_7_Expected);
+    testsUserPrograms.push_back(test_7_UserPrograms);
+    testsHints.push_back(test_7_Hint);
+
+    testsInputs.push_back(test_8_Input);
+    testsExpected.push_back(test_8_Expected);
+    testsUserPrograms.push_back(test_8_UserPrograms);
+    testsHints.push_back(test_8_Hint);
+
+    testsInputs.push_back(test_9_Input);
+    testsExpected.push_back(test_9_Expected);
+    testsUserPrograms.push_back(test_9_UserPrograms);
+    testsHints.push_back(test_9_Hint);
+
+    testsInputs.push_back(test_10_Input);
+    testsExpected.push_back(test_10_Expected);
+    testsUserPrograms.push_back(test_10_UserPrograms);
+    testsHints.push_back(test_10_Hint);
+
+    testsInputs.push_back(test_11_Input);
+    testsExpected.push_back(test_11_Expected);
+    testsUserPrograms.push_back(test_11_UserPrograms);
+    testsHints.push_back(test_11_Hint);
+
+    testsInputs.push_back(test_12_Input);
+    testsExpected.push_back(test_12_Expected);
+    testsUserPrograms.push_back(test_12_UserPrograms);
+    testsHints.push_back(test_12_Hint);
+
+    testsInputs.push_back(test_13_Input);
+    testsExpected.push_back(test_13_Expected);
+    testsUserPrograms.push_back(test_13_UserPrograms);
+    testsHints.push_back(test_13_Hint);
+
+    testsInputs.push_back(test_14_Input);
+    testsExpected.push_back(test_14_Expected);
+    testsUserPrograms.push_back(test_14_UserPrograms);
+    testsHints.push_back(test_14_Hint);
+
+    testsInputs.push_back(test_15_Input);
+    testsExpected.push_back(test_15_Expected);
+    testsUserPrograms.push_back(test_15_UserPrograms);
+    testsHints.push_back(test_15_Hint);
+
+    testsInputs.push_back(test_16_Input);
+    testsExpected.push_back(test_16_Expected);
+    testsUserPrograms.push_back(test_16_UserPrograms);
+    testsHints.push_back(test_16_Hint);
+
+    testsInputs.push_back(test_17_Input);
+    testsExpected.push_back(test_17_Expected);
+    testsUserPrograms.push_back(test_17_UserPrograms);
+    testsHints.push_back(test_17_Hint);
+
+    testsInputs.push_back(test_18_Input);
+    testsExpected.push_back(test_18_Expected);
+    testsUserPrograms.push_back(test_18_UserPrograms);
+    testsHints.push_back(test_18_Hint);
+
+    testsInputs.push_back(test_19_Input);
+    testsExpected.push_back(test_19_Expected);
+    testsUserPrograms.push_back(test_19_UserPrograms);
+    testsHints.push_back(test_19_Hint);
+
+    testsInputs.push_back(test_20_Input);
+    testsExpected.push_back(test_20_Expected);
+    testsUserPrograms.push_back(test_20_UserPrograms);
+    testsHints.push_back(test_20_Hint);
+}
+
+/* ### Example of use ###
+
+// Executing DEMO_TEST
+void DEMO_TEST()
+{
+  // Initializing
+  currentTestName = DEMO_TEST
+
+  // Testing
+
+  test(0,"got","expected");
+
+  try
+  {
+    test(1,"maybe exception will be thrwon from here,"$$$ ASSERT_THROWN_EXCEPTIONS $$$");
+  }
+  catch (ExceptionType exp)
+  {
+    test("","$$$ DECLARE GOOD TEST $$$");
+  }
+
+}
+*/
+
+// Processing test
+bool procceseTest(string testName,unsigned int testNumber){
+    // Initializing 
+    string testBaseFolder = "Tests/" + testName;
+    string testFolder = "./Project_Test/" + testBaseFolder;
+    string testInputFileName = "/testInput.txt";
+    string testOutputFileName = "/testOutput.txt";
+    string testMakefileErrorFileName = "/makefileError.txt";
+    string testMakefileCommandFileName = "/makefileCommandForDebug.txt";
+    string testsExpectedFileName = "/testExpected.txt";
+    int testCompletedFlag;
+
+    // Creating XV6 Tests Folder
+    createXV6_TestMakefile(testBaseFolder + "/Makefile",testsUserPrograms.at(testNumber));
+
+    // Executing test
+    string makefileCommand = "make --makefile=" + testFolder +  "/Makefile clean qemu ";
+    string test_command = "cd .. && " + makefileCommand + " -s < " + testFolder + testInputFileName;
+    string got_test = GetStdoutFromCommandAsync(test_command,"Finished Yehonatan Peleg Test, quiting...",timeForSmallTest,testCompletedFlag);    
+    
+    // Creating Test Makefile command
+    std::ofstream outCommand(testBaseFolder + testMakefileCommandFileName);
+    outCommand << makefileCommand;
+    outCommand.close();
+
+    // Processing test output
+    got_test = processTestOutput(got_test);
+
+    // Writing test output to file
+    std::ofstream out(testBaseFolder + testOutputFileName);
+    out << got_test;
+    out.close();
+
+    // Retrieving test hint 
+    string test_hint = testsHints.at(testNumber);
+
+    // Asserting test completed
+    if(testCompletedFlag == 1){
+        // Retrieving test expected
+        string expected_test = processCompareString(testsExpected.at(testNumber));
+
+        if(expected_test.at(0) == '#'){
+          if(got_test.find(expected_test.substr(1)) != std::string::npos){
+              test(testNumber,"","$$$ DECLARE GOOD TEST $$$");
+          }
+          else{
+              test(testNumber,got_test,"Output should have contain this: \n" + expected_test,vector<string>{"String value with /n",test_hint});
+          }
+          
+        }
+        else if(expected_test.at(0) == '+'){
+            if(countSubStr(got_test,expected_test.substr(2)) == (expected_test.at(1) - '0')){
+                test(testNumber,"","$$$ DECLARE GOOD TEST $$$");
+            }
+            else{
+               test(testNumber,got_test,"Output should have contain this: \n" + expected_test.substr(2) + "\n" + 
+                    expected_test.at(1) + " times",vector<string>{"String value with /n",test_hint});
+            }
+        }
+        else{
+            test(testNumber,got_test,expected_test,vector<string>{"String value with /n",test_hint});
+        }
+    }
+    else if(testCompletedFlag == 0){
+      // Creating Test Expected
+      std::ofstream outError(testBaseFolder + testMakefileErrorFileName);
+      outError << got_test;
+      outError.close();
+
+      // Declaring Test Execution Ended With Timeout
+      test(testNumber,"$$$ SMALL TEST EXECUTION TIMED OUT $$$","",vector<string>{"",test_hint});
+    }
+    else{
+      // Declaring Test Execution Ended With Error
+      test(testNumber,"$$$ TEST EXECUTION ERROR $$$","");
+    }
+
+    return 0;
+}
+
+// Running specific test
+void runSpecificTest(int testToExecute){
+    // Initializing
+    string test_name = "test_" + std::to_string(testToExecute);
+  
+    // Declaring specific test is running
+    printf("Running ");
+    printf("test_");
+    printf("%d for specific test request\n\n",testToExecute);
+
+    // Runnig specific test
+    procceseTest(test_name,testToExecute);
+}
+
+// Creating Tests
+unsigned int CreateTests()
+{
+  // Creating Tests Folder
+  string createTestFolderCommand = "rm -rf Tests && mkdir Tests";
+  string got_createTestFolder = GetStdoutFromCommand(createTestFolderCommand);
+
+   // Creating Tests
+  for(unsigned int i = 0;i < testsInputs.size();i++)
+  { 
+    // Retrieving current test to create
+    string currentTestInput = testsInputs.at(i);
+    string currentTestExpected = testsExpected.at(i);
+
+    // Defining Test Folder
+    string testFolder = "./Tests/test_" + std::to_string(i);
+    string testFile = testFolder + "/" + "testInput" + ".txt";
+    string testExpectedFile = testFolder + "/" + "testExpected" + ".txt";
+
+    // Creating Current Test Files  
+    string createTestsFilesCommand = "mkdir " + testFolder + " && touch " + testFile;
+    string got_createTestsFilesCommand  = GetStdoutFromCommand(createTestsFilesCommand );
+
+    // Creating Test Input
+    std::ofstream outInput(testFile);
+    outInput << currentTestInput + "\nquitXV6\n";
+    outInput.close();
+
+    // Creating Test Expected
+    std::ofstream outExpected(testExpectedFile);
+    outExpected << processCompareString(currentTestExpected);
+    outExpected.close();
+  }
+
+  return testsInputs.size();
+}
+
+// Signal handler for SIGINT
+void sigintHandler(int num){
+    abortExecution = 1;
+
+    // Catching signal
+    signal(SIGINT,sigintHandler);
+}
+
+// Processing test output
+string processTestOutput(string output){
+  // Serching for start of test code
+  unsigned int inputStartPos = output.find("$",0);
+
+  // Returning test code
+  if(inputStartPos < output.length() && inputStartPos >= 0){
+      return processCompareString(output.substr(inputStartPos,output.length())); 
+  }
+  else{
+      return output;
+  }
+}
+
+// Processing compare string, i.e removing spaces from edges
+string processCompareString(string str){
+    // Initializing
+    int start = -1;
+    int end = -1;
+
+    // Retrieving location of first space from start
+    for(unsigned int i = 0;i < str.length();i++){
+      if(str.at(i) > 32){
+        start = i;
+        break;
+      }
+    }
+
+    // Retrieving location of first space from end
+    for(unsigned int i = str.length() - 1;i >= 0;i--){
+      if(str.at(i) > 32){
+        end = i;
+        break;
+      }
+    }
+
+    // Asserting there are spaces at the edegs and if so removing them
+    if(start == -1 || end == -1){
+      return str;
+    }
+    else{
+      return str.substr(start,end - start + 1);
+    }
+
+}
+
+// Creating XV6 Tests Makefile
+void createXV6_TestMakefile(string makefilePath,vector<string> userspacePrograms){
+    // Initializing
+    string data;
+    FILE * stream = fopen("../Makefile","r");
+    const int max_buffer = 4000;
+    char buffer[max_buffer];
+    string xv6TestsBaseFolder = "XV6_Tests/";
+    string xv6TestsQEMUFolder = "./Project_Test/" + xv6TestsBaseFolder;
+    string userSpaceProgramMakeCode =  
+  "_%: ulib.o usys.o printf.o umalloc.o\n" 
+  "\tgcc -fno-pic -std=gnu99 -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer " 
+  "\t-fno-stack-protector -fno-pie -no-pie -fno-pic -static " 
+	"\t-fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -march=i686 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie  -c -o %.o #.c\n" 
+ "\tld -m    elf_i386 -N -e main -Ttext 0 -o _% %.o ulib.o usys.o printf.o umalloc.o\n" 
+	"\tobjdump -S _% > %.asm\n" 
+	"\t$(OBJDUMP) -t _% | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > %.sym\n";
+
+    // Reading project makefile and adding tests user space programs
+    // while code is for telling the makefile to include these user space programs
+    while (!feof(stream))
+    { 
+      // Reading line of test output
+      if (fgets(buffer, max_buffer, stream) != NULL){
+          if(strstr(buffer,"UPROGS=\\")){
+              data.append("UPROGS=  " + processAppendMakefileUPROGS(userspacePrograms));
+          }
+          else{
+              data.append(buffer);
+          }
+      }
+     
+    }
+
+    // Adding build commands for each user space program
+    for (vector<string>::iterator it = userspacePrograms.begin() ; it != userspacePrograms.end(); ++it){
+      string temp = replaceInString(userSpaceProgramMakeCode,'%',*it) + "\n";
+      data.append(replaceInString(temp,'#',xv6TestsQEMUFolder + *it));
+    }
+    
+    // Creating Tests Makefile
+    std::ofstream outMakefile(makefilePath);
+    outMakefile << data;
+    outMakefile.close();
+}
+
+// Processing user space programs and creating an entry for each one 
+// inorder to take the makefile of the xv6 to include them
+string processAppendMakefileUPROGS(vector<string> append){
+    // Initializinh
+    string result;
+
+    // Creating entries
+    for (vector<string>::iterator it = append.begin() ; it != append.end(); ++it){
+      result.append("_" + *it + "\\\n");
+    }
+
+    return result;
+}
+
+// Replacing all occurences of toReplace char with replaceWith string in str
+string replaceInString(string str,char toReplace,string replaceWith){
+    // Initializing
+    string result;
+
+    // Replacing
+    for (string::iterator it=str.begin(); it!=str.end(); ++it){
+        if(*it == toReplace){
+          result.append(replaceWith);
+        }
+        else{
+          result.append(1,*it);
+        }
+    }
+
+    return result;
+}
+
+// Finding number of occurences of substr in string
+int countSubStr(string str,string findSubStr){
+    // Initializing
+    int occurrences = 0;
+    string::size_type pos = 0;
+
+    // Counting
+    while ((pos = str.find(findSubStr, pos)) != std::string::npos) {
+          ++occurrences;
+          pos += findSubStr.length();
+    }
+   
+   return occurrences;
+}
+
+// Executing Operating_System_Test
+void Operating_System_Test()
+{
+  // Initializing
+  currentTestName = "Operating_System_Test";
+  char arr[50];
+  memset(arr,' ',50);
+  arr[50] = 0;
+  int progress_index = 0;
+  int progress;
+  const char* no_error_progress = "\e[38;5;082m[%s]\e[38;5;226m%i%% %d/%d\r\e[0m";
+  const char* yes_error_progress = "\e[38;5;082m[%s]\e[38;5;196m%i%% %d/%d\r\e[0m";
+
+  // Creating Tests
+  unsigned int numberOfTests = CreateTests();
+  
+  // Running specific test if demanded
+  if(0 <=  testToExecute && ((unsigned int)testToExecute) < numberOfTests){
+      runSpecificTest(testToExecute);
+      return;
+  }
+  else if(testToExecute != -1){
+      printf("Specific test request was out of bounds(%d)\n\n",testToExecute);
+  }
+
+  // Printing initial progress
+  printf(no_error_progress,arr,0,0,numberOfTests);
+  fflush(stdout);
+
+  // Testing
+  for(unsigned int i = 0;i < numberOfTests;i++)
+  { 
+    // Testing
+    if(abortExecution == 0){
+      procceseTest("test_" + std::to_string(i),i);
+    }
+    else{
+      // Declaring test was aborted
+      cout << RED << std::endl << "Operating System Test Was Aborted With " << i << " Tests Executed Out Of " << numberOfTests << " !!!" << RESET << std::endl;
+      red = red + (numberOfTests - i);
+      break;
+    }
+
+    float float_index = (float)(i + 1);
+    progress = (float_index/numberOfTests) * 100;
+
+    // Updating progress 
+    if(progress > progress_index)
+    { 
+      progress_index += 1;
+      memset(arr,'#',(int)((float_index/numberOfTests) * 50));
+    }
+    
+    if(red == 0){
+      printf(no_error_progress,arr,progress,i+1,numberOfTests);
+    }
+    else{
+      printf(yes_error_progress,arr,progress,i+1,numberOfTests);
+    }
+    fflush(stdout);
+  }
+  
+  // Cleaning after progress bar
+  printf("%%\r                                                                          %%\r");
+}
diff --git a/Project_Test/src/temp.cpp b/Project_Test/src/temp.cpp
new file mode 100755
index 0000000..e69de29
diff --git a/ass1ds.cpp b/ass1ds.cpp
index b93fb11..91e22a8 100644
--- a/ass1ds.cpp
+++ b/ass1ds.cpp
@@ -2,9 +2,11 @@
 
 extern "C" {
 	char*                         kalloc();
+	void                          panic(char*) __attribute__((noreturn));
 	void*                         memset(void*, int, uint);
 	void                          initSchedDS();
 	long long                     getAccumulator(Proc *p);
+	long long                     __moddi3(long long number, long long divisor);
 
 	//for pq
 	static boolean                isEmptyPriorityQueue();
@@ -48,7 +50,7 @@ static MapNode                    *freeNodes;
 
 static char                       *data;
 static uint                       spaceLeft;
-                
+
 static char* mymalloc(uint size) {
 	if(spaceLeft < size) {
 		data = kalloc();
@@ -212,7 +214,7 @@ static MapNode* allocNode(Proc *p, long long key) {
 	if(!ans)
 		return null;
 
-	if(!ans->listOfProcs.enqueue(p)){
+	if(!ans->listOfProcs.enqueue(p)) {
 		deallocNode(ans);
 		return null;
 	}
@@ -222,7 +224,7 @@ static MapNode* allocNode(Proc *p, long long key) {
 
 Link* Link::getLast() {
 	Link* ans = this;
-	
+
 	while(ans->next)
 		ans = ans->next;
 
@@ -245,7 +247,7 @@ void LinkedList::append(Link *link) {
 
 bool LinkedList::enqueue(Proc *p) {
 	Link *link = allocLink(p);
-	
+
 	if(!link)
 		return false;
 
@@ -259,21 +261,21 @@ Proc* LinkedList::dequeue() {
 
 	Proc *p = first->p;
 	Link *next = first->next;
-	
+
 	deallocLink(first);
-	
+
 	first = next;
 
 	if(isEmpty())
 		last = null;
-	
+
 	return p;
 }
 
 bool LinkedList::remove(Proc *p) {
 	if(isEmpty())
 		return false;
-	
+
 	if(first->p == p) {
 		dequeue();
 		return true;
@@ -284,7 +286,7 @@ bool LinkedList::remove(Proc *p) {
 	while(cur) {
 		if(cur->p == p) {
 			prev->next = cur->next;
-			
+
 			if(!(cur->next)) //removes the last link
 				last = prev;
 
@@ -304,15 +306,17 @@ bool LinkedList::remove(Proc *p) {
 bool LinkedList::transfer() {
 	if(!priorityQ->isEmpty())
 		return false;
-	
-	MapNode *node = allocNode(0);
-	if(!node)
-		return false;
-	
-	node->listOfProcs.first = first;
-	node->listOfProcs.last = last;
-	first = last = null;
-	priorityQ->root = node;
+
+	if(!isEmpty()) {
+		MapNode *node = allocNode(0);
+		if(!node)
+			return false;
+
+		node->listOfProcs.first = first;
+		node->listOfProcs.last = last;
+		first = last = null;
+		priorityQ->root = node;
+	}
 	return true;
 }
 
@@ -321,7 +325,7 @@ bool LinkedList::getMinKey(long long *pkey) {
 		return false;
 
 	long long minKey = getAccumulator(first->p);
-	
+
 	forEach([&](Proc *p) {
 		long long key = getAccumulator(p);
 		if(key < minKey)
@@ -329,7 +333,7 @@ bool LinkedList::getMinKey(long long *pkey) {
 	});
 
 	*pkey = minKey;
-	
+
 	return true;
 }
 
@@ -370,7 +374,7 @@ bool MapNode::put(Proc *p) { //we can not use recursion, since the stack of xv6
 }
 
 MapNode* MapNode::getMinNode() { //no recursion.
-	MapNode* minNode = this;	
+	MapNode* minNode = this;
 	while(minNode->left)
 		minNode = minNode->left;
 
@@ -395,7 +399,7 @@ bool Map::put(Proc *p) {
 		root = allocNode(p, key);
 		return !isEmpty();
 	}
-	
+
 	return root->put(p);
 }
 
@@ -414,7 +418,7 @@ Proc* Map::extractMin() {
 	MapNode *minNode = root->getMinNode();
 
 	Proc *p = minNode->dequeue();
-	
+
 	if(minNode->isEmpty()) {
 		if(minNode == root) {
 			root = minNode->right;
@@ -459,3 +463,29 @@ bool Map::extractProc(Proc *p) {
 	root = tempMap.root;
 	return ans;
 }
+
+long long __moddi3(long long number, long long divisor) { //returns number%divisor
+	if(divisor == 0)
+		panic((char*)"divide by zero!!!\n");
+
+	bool isNumberNegative = false;
+	if(number < 0) {
+		number = -number;
+		isNumberNegative = true;
+	}
+
+	if(divisor < 0)
+		divisor = -divisor;
+
+	for(;;) {
+		long long divisor2 = divisor;
+		while(number >= divisor2) {
+			number -= divisor2;
+			if(divisor2 + divisor2 > 0) //exponential decay.
+				divisor2 += divisor2;
+		}
+
+		if(number < divisor)
+			return isNumberNegative ? -number : number;
+	}
+}
diff --git a/cat.c b/cat.c
index 5ddc820..ed1987d 100644
--- a/cat.c
+++ b/cat.c
@@ -12,12 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      exit();
+      exit(0);
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit();
+    exit(0);
   }
 }
 
@@ -28,16 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     cat(fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/defs.h b/defs.h
index 82fb982..ab6d763 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct perf;
 
 // bio.c
 void            binit(void);
@@ -104,7 +105,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-void            exit(void);
+void            exit(int status);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -117,9 +118,13 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(void);
+int             wait(int *status);
 void            wakeup(void*);
 void            yield(void);
+int             detach(int pid);
+void            policy(int policy);
+void            priority(int priority);
+int             wait_stat(int *status, struct perf *performance);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -161,7 +166,7 @@ void            timerinit(void);
 
 // trap.c
 void            idtinit(void);
-extern uint     ticks;
+extern /*volatile*/ uint     ticks;
 void            tvinit(void);
 extern struct spinlock tickslock;
 
diff --git a/dot-bochsrc b/dot-bochsrc
index ba13db7..5341b84 100644
--- a/dot-bochsrc
+++ b/dot-bochsrc
@@ -9,8 +9,8 @@
 # There are two choices of configuration interface: a text mode version
 # called "textconfig" and a graphical version called "wx".  The text
 # mode version uses stdin/stdout and is always compiled in.  The graphical
-# version is only available when you use "--with-wx" on the configure 
-# command.  If you do not write a config_interface line, Bochs will 
+# version is only available when you use "--with-wx" on the configure
+# command.  If you do not write a config_interface line, Bochs will
 # choose a default for you.
 #
 # NOTE: if you use the "wx" configuration interface, you must also use
@@ -22,14 +22,14 @@
 #=======================================================================
 # DISPLAY_LIBRARY
 #
-# The display library is the code that displays the Bochs VGA screen.  Bochs 
-# has a selection of about 10 different display library implementations for 
-# different platforms.  If you run configure with multiple --with-* options, 
+# The display library is the code that displays the Bochs VGA screen.  Bochs
+# has a selection of about 10 different display library implementations for
+# different platforms.  If you run configure with multiple --with-* options,
 # the display_library command lets you choose which one you want to run with.
 # If you do not write a display_library line, Bochs will choose a default for
 # you.
 #
-# The choices are: 
+# The choices are:
 #   x              use X windows interface, cross platform
 #   win32          use native win32 libraries
 #   carbon         use Carbon library (for MacOS X)
@@ -94,7 +94,7 @@ romimage: file=$BXSHARE/BIOS-bochs-latest
 #  Measured IPS value will then be logged into your log file or status bar
 #  (if supported by the gui).
 #
-#  IPS is used to calibrate many time-dependent events within the bochs 
+#  IPS is used to calibrate many time-dependent events within the bochs
 #  simulation.  For example, changing IPS affects the frequency of VGA
 #  updates, the duration of time before a key starts to autorepeat, and
 #  the measurement of BogoMips and other benchmarks.
@@ -111,7 +111,7 @@ cpu: count=2, ips=10000000
 
 #=======================================================================
 # MEGS
-# Set the number of Megabytes of physical memory you want to emulate. 
+# Set the number of Megabytes of physical memory you want to emulate.
 # The default is 32MB, most OS's won't need more than that.
 # The maximum amount of memory supported is 2048Mb.
 #=======================================================================
@@ -124,11 +124,11 @@ megs: 32
 
 #=======================================================================
 # OPTROMIMAGE[1-4]:
-# You may now load up to 4 optional ROM images. Be sure to use a 
+# You may now load up to 4 optional ROM images. Be sure to use a
 # read-only area, typically between C8000 and EFFFF. These optional
 # ROM images should not overwrite the rombios (located at
 # F0000-FFFFF) and the videobios (located at C0000-C7FFF).
-# Those ROM images will be initialized by the bios if they contain 
+# Those ROM images will be initialized by the bios if they contain
 # the right signature (0x55AA) and a valid checksum.
 # It can also be a convenient way to upload some arbitrary code/data
 # in the simulation, that can be retrieved by the boot loader
@@ -203,10 +203,10 @@ floppyb: 1_44=b.img, status=inserted
 # ATA controller for hard disks and cdroms
 #
 # ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
-# 
+#
 # These options enables up to 4 ata channels. For each channel
 # the two base io addresses and the irq must be specified.
-# 
+#
 # ata0 and ata1 are enabled by default with the values shown below
 #
 # Examples:
@@ -224,7 +224,7 @@ ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
 # ATA[0-3]-MASTER, ATA[0-3]-SLAVE
 #
 # This defines the type and characteristics of all attached ata devices:
-#   type=       type of attached device [disk|cdrom] 
+#   type=       type of attached device [disk|cdrom]
 #   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
 #   mode=       only valid for disks [undoable|growing|volatile]
 #   path=       path of the image
@@ -236,16 +236,16 @@ ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
 #   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
 #   model=      string returned by identify device command
 #   journal=    optional filename of the redolog for undoable and volatile disks
-#   
+#
 # Point this at a hard disk image file, cdrom iso file, or physical cdrom
 # device.  To create a hard disk image, try running bximage.  It will help you
 # choose the size and then suggest a line that works with it.
 #
-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+# In UNIX it may be possible to use a raw device as a Bochs hard disk,
 # but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
 #
 # In windows, the drive letter + colon notation should be used for cdroms.
-# Depending on versions of windows and drivers, you may only be able to 
+# Depending on versions of windows and drivers, you may only be able to
 # access the "first" cdrom in the system.  On MacOSX, use path="drive"
 # to access the physical drive.
 #
@@ -274,7 +274,7 @@ ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
 #ata0-slave: type=cdrom, path=D:, status=inserted
 #ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
 #ata0-slave: type=cdrom, path="drive", status=inserted
-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted
 
 #=======================================================================
 # BOOT:
@@ -300,9 +300,9 @@ boot: disk
 #  TO BE COMPLETED (see Greg explanation in feature request #536329)
 #
 #  TIME0:
-#  Specifies the start (boot) time of the virtual machine. Use a time 
-#  value as returned by the time(2) system call. If no time0 value is 
-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+#  Specifies the start (boot) time of the virtual machine. Use a time
+#  value as returned by the time(2) system call. If no time0 value is
+#  set or if time0 equal to 1 (special case) or if time0 equal 'local',
 #  the simulation will be started at the current local host time.
 #  If time0 equal to 2 (special case) or if time0 equal 'utc',
 #  the simulation will be started at the current utc time.
@@ -318,7 +318,7 @@ boot: disk
 #   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
 #   clock: sync=none,     time0=1           # Now (localtime)
 #   clock: sync=none,     time0=utc         # Now (utc/gmt)
-# 
+#
 # Default value are sync=none, time0=local
 #=======================================================================
 #clock: sync=none, time0=local
@@ -357,7 +357,7 @@ log: bochsout.txt
 #   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
 #   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
 #   %d : 5 characters string of the device, between brackets
-# 
+#
 # Default : %t%e%d
 # Examples:
 #   logprefix: %t-%e-@%i-%d
@@ -369,7 +369,7 @@ log: bochsout.txt
 # LOG CONTROLS
 #
 # Bochs now has four severity levels for event logging.
-#   panic: cannot proceed.  If you choose to continue after a panic, 
+#   panic: cannot proceed.  If you choose to continue after a panic,
 #          don't be surprised if you get strange behavior or crashes.
 #   error: something went wrong, but it is probably safe to continue the
 #          simulation.
@@ -383,7 +383,7 @@ log: bochsout.txt
 #
 # If you are experiencing many panics, it can be helpful to change
 # the panic action to report instead of fatal.  However, be aware
-# that anything executed after a panic is uncharted territory and can 
+# that anything executed after a panic is uncharted territory and can
 # cause bochs to become unstable.  The panic is a "graceful exit," so
 # if you disable it you may get a spectacular disaster instead.
 #=======================================================================
@@ -514,7 +514,7 @@ keyboard_serial_delay: 250
 # characters to the keyboard controller. This leaves time for the
 # guest os to deal with the flow of characters.  The ideal setting
 # depends on how your operating system processes characters.  The
-# default of 100000 usec (.1 seconds) was chosen because it works 
+# default of 100000 usec (.1 seconds) was chosen because it works
 # consistently in Windows.
 #
 # If your OS is losing characters during a paste, increase the paste
@@ -526,7 +526,7 @@ keyboard_serial_delay: 250
 keyboard_paste_delay: 100000
 
 #=======================================================================
-# MOUSE: 
+# MOUSE:
 # This option prevents Bochs from creating mouse "events" unless a mouse
 # is  enabled. The hardware emulation itself is not disabled by this.
 # You can turn the mouse on by setting enabled to 1, or turn it off by
@@ -563,7 +563,7 @@ private_colormap: enabled=0
 
 #=======================================================================
 # fullscreen: ONLY IMPLEMENTED ON AMIGA
-#             Request that Bochs occupy the entire screen instead of a 
+#             Request that Bochs occupy the entire screen instead of a
 #             window.
 #
 # Examples:
@@ -591,11 +591,11 @@ private_colormap: enabled=0
 # ethdev: The ethdev value is the name of the network interface on your host
 # platform.  On UNIX machines, you can get the name by running ifconfig.  On
 # Windows machines, you must run niclist to get the name of the ethdev.
-# Niclist source code is in misc/niclist.c and it is included in Windows 
+# Niclist source code is in misc/niclist.c and it is included in Windows
 # binary releases.
 #
-# script: The script value is optional, and is the name of a script that 
-# is executed after bochs initialize the network interface. You can use 
+# script: The script value is optional, and is the name of a script that
+# is executed after bochs initialize the network interface. You can use
 # this script to configure this network interface, or enable masquerading.
 # This is mainly useful for the tun/tap devices that only exist during
 # Bochs execution. The network interface name is supplied to the script
@@ -625,10 +625,10 @@ private_colormap: enabled=0
 
 #=======================================================================
 # KEYBOARD_MAPPING:
-# This enables a remap of a physical localized keyboard to a 
+# This enables a remap of a physical localized keyboard to a
 # virtualized us keyboard, as the PC architecture expects.
 # If enabled, the keymap file must be specified.
-# 
+#
 # Examples:
 #   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
 #=======================================================================
diff --git a/echo.c b/echo.c
index 806dee0..eed68a0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
+  exit(0);
 }
diff --git a/exec.c b/exec.c
index b40134f..d07ea7a 100644
--- a/exec.c
+++ b/exec.c
@@ -23,7 +23,6 @@ exec(char *path, char **argv)
 
   if((ip = namei(path)) == 0){
     end_op();
-    cprintf("exec: fail\n");
     return -1;
   }
   ilock(ip);
diff --git a/fcntl.h b/fcntl.h
index d565483..d2a6527 100644
--- a/fcntl.h
+++ b/fcntl.h
@@ -2,3 +2,5 @@
 #define O_WRONLY  0x001
 #define O_RDWR    0x002
 #define O_CREATE  0x200
+#define S_IROTH   0x004
+#define S_IWOTH   0x002
diff --git a/file.c b/file.c
index 24b32c2..25e3a4e 100644
--- a/file.c
+++ b/file.c
@@ -154,4 +154,3 @@ filewrite(struct file *f, char *addr, int n)
   }
   panic("filewrite");
 }
-
diff --git a/forktest.c b/forktest.c
index 8bc984d..4cbcb17 100644
--- a/forktest.c
+++ b/forktest.c
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(0);
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit();
+    exit(0);
   }
 
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(0) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(0);
     }
   }
 
-  if(wait() != -1){
+  if(wait(0) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit();
+  exit(0);
 }
diff --git a/grep.c b/grep.c
index adc4835..1aa1081 100644
--- a/grep.c
+++ b/grep.c
@@ -43,24 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit();
+    exit(0);
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    exit();
+    exit(0);
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/init.c b/init.c
index 046b551..8da3b90 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit();
+      exit(0);
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit();
+      exit(0);
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+    while((wpid=wait(0)) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/initcode.S b/initcode.S
index 80ac5d8..b8229b8 100644
--- a/initcode.S
+++ b/initcode.S
@@ -14,7 +14,7 @@ start:
   movl $SYS_exec, %eax
   int $T_SYSCALL
 
-# for(;;) exit();
+# for(;;) exit(0);
 exit:
   movl $SYS_exit, %eax
   int $T_SYSCALL
diff --git a/kill.c b/kill.c
index 364f6af..5a2e450 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 2){
     printf(2, "usage: kill pid...\n");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit();
+  exit(0);
 }
diff --git a/ln.c b/ln.c
index cf8a64e..14acdc8 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit();
+    exit(0);
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
+  exit(0);
 }
diff --git a/ls.c b/ls.c
index 2862913..27742c2 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit();
+  exit(0);
 }
diff --git a/main.c b/main.c
index 6c9e227..588b282 100644
--- a/main.c
+++ b/main.c
@@ -33,7 +33,7 @@ main(void)
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   initSchedDS(); // initialize the data structures for the processes sceduling policies
@@ -134,4 +134,3 @@ pde_t entrypgdir[NPDENTRIES] = {
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..d101838 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/policy.c b/policy.c
new file mode 100644
index 0000000..b7b8196
--- /dev/null
+++ b/policy.c
@@ -0,0 +1,14 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+#include "stat.h"
+
+int
+main(int argc, char **argv)
+{
+  const char *policyList[3] = { "ROUND_ROBIN", "PRIORITY", "E_PRIORITY" };
+  int pol = atoi(argv[1]);
+  policy(pol);
+  printf(2, "The policy changed to: %s\n",policyList[--pol]);
+  exit(0);
+}
diff --git a/proc.c b/proc.c
index e68bf1c..2bf1e24 100644
--- a/proc.c
+++ b/proc.c
@@ -13,16 +13,75 @@ extern RoundRobinQueue rrq;
 extern RunningProcessesHolder rpholder;
 
 long long getAccumulator(struct proc *p) {
-	//Implement this function, remove the panic line.
-	panic("getAccumulator: not implemented\n");
+	return p->accumulator;
 }
 
+enum policy { ROUND_ROBIN, PRIORITY, E_PRIORITY };
+volatile int pol = ROUND_ROBIN;
+int min_priority = 0;
+int max_priority = 10;
+volatile uint time_quantum_counter = 1;
+long long MAX_LONG  = 9223372036854775807;
+
+
+#define DEFAULT_PRIORITY 5
+#define NEW_PROCESS 1 	//true
+#define OLD_PROCESS 0		//false
+
+static void getTicks(uint * currtick);
+static void (*volatile switchFromPolicy)(int toPolicy);
+static void (*volatile signToQ)(struct proc * p , int isNew);
+static struct proc * (*volatile getProc)(void);
+static boolean (*volatile isQEmpty)(void);
+
+static void  switchFromRRQ (int toPolicy);
+static void  switchFromPQ (int toPolicy);
+static void  switchFromExtPQ (int toPolicy);
+
+static void signToRRQ(struct proc * p , int isNew);
+static void signToPQ(struct proc * p , int isNew);
+static void signToExtPQ(struct proc * p , int isNew);
+
+static struct proc * getRRQProc(void);
+static struct proc * getPQProc(void);
+static struct proc * getExtPQProc(void);
+
+static boolean isEmptyRRQ(void);
+static boolean isEmptyPQ(void);
+
+static void updateMinAccumulator(struct proc* p);
+
+void (*switchFromPolicyArr[])(int toPolicy) = {
+	[0] switchFromRRQ,
+	[1] switchFromPQ,
+	[2] switchFromExtPQ
+};
+
+void (* signToQArr [])(struct proc * p , int isNew) = {
+	[0] signToRRQ,
+	[1] signToPQ,
+	[2] signToExtPQ
+};
+
+struct proc * (*getProcArr [3])(void) = {
+	[0] getRRQProc,
+	[1] getPQProc,
+	[2] getExtPQProc
+};
+
+boolean (*isQEmptyArr [3])(void) = {
+	[0] isEmptyRRQ,
+	[1] isEmptyPQ,
+	[2] isEmptyPQ
+};
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
 
 static struct proc *initproc;
+static struct proc *lastProc = 0;
 
 int nextpid = 1;
 extern void forkret(void);
@@ -30,9 +89,199 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+void policy(int toPolicy) {
+
+	if(toPolicy < 0 || toPolicy > 2){
+		//panic("The policy number is not in range...\n");
+		cprintf("The policy number is not in range...\n");
+		return;
+	}
+	if(pol == toPolicy){
+		cprintf("Allready in this policy, doing nothing...\n");
+		return;
+	}
+	acquire(&ptable.lock);
+	switchFromPolicy(toPolicy);
+	pol = toPolicy;
+	switchFromPolicy = switchFromPolicyArr[toPolicy];
+	signToQ = signToQArr[toPolicy];
+	getProc = getProcArr[toPolicy];
+	isQEmpty = isQEmptyArr[toPolicy];
+	release(&ptable.lock);
+}
+
+boolean isEmptyRRQ(){
+	return rrq.isEmpty();
+}
+
+boolean isEmptyPQ(){
+	return pq.isEmpty();
+}
+
+void switchFromRRQ (int toPolicy){
+	struct proc *pr;
+	if(!rrq.switchToPriorityQueuePolicy()){
+		panic("switchFromRRQ: falied");
+	}
+	if(toPolicy == E_PRIORITY){
+			min_priority = 0;
+		}
+	else{
+		min_priority = 1;
+		for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
+			pr->priority = pr->priority == 0 ? 1 :pr->priority;
+		}
+	}
+}
+
+void switchFromPQ (int toPolicy){
+struct proc * pr;
+	if(toPolicy == ROUND_ROBIN){
+			if(!pq.switchToRoundRobinPolicy()){
+				panic("switchFromPQ: falied");
+
+			}
+			for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
+				pr->accumulator = 0;
+			}
+	}
+	else {
+		min_priority=0;
+	}
+}
+void switchFromExtPQ (int toPolicy){
+	struct proc * pr;
+	if(toPolicy == ROUND_ROBIN){
+			if(!pq.switchToRoundRobinPolicy()){
+				panic("switchFromExtPQ: falied");
+			}
+
+			for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
+				pr->accumulator = 0;
+			}
+	}
+		else {
+			for (pr = ptable.proc; pr < &ptable.proc[NPROC]; pr++) {
+				pr->priority = pr->priority == 0 ? 1 :pr->priority;
+			}
+			min_priority = 1;
+	}
+
+}
+
+
+void handleSettings(struct proc * p,int isNew){
+	uint currtick;
+	getTicks(&currtick);
+	p->readyStartTime = currtick;
+	if(!isNew){
+		p->rutime += (currtick - p->startRunningTime);
+		if(pol != ROUND_ROBIN){
+			p->accumulator = p->accumulator + p->priority;
+		}
+	}
+	else{
+		//newestProc = p;
+		if(pol != ROUND_ROBIN){
+			updateMinAccumulator(p);
+		}
+	}
+}
+
+void signToRRQ(struct proc * p , int isNew){
+if (p->state == RUNNABLE){
+	handleSettings(p, isNew);
+	rrq.enqueue(p);
+}
+	else panic("signToRRQ: proc not Runnable!\n");
+
+}
+void signToPQ(struct proc * p , int isNew){
+	if (p->state == RUNNABLE){
+	handleSettings(p, isNew);
+
+	pq.put(p);
+}
+	else panic("signToPQ: proc not Runnable!\n");
+}
+void signToExtPQ(struct proc * p , int isNew){
+	if (p->state == RUNNABLE){
+
+		handleSettings(p, isNew);
+
+		pq.put(p);
+}
+	else panic("signToExtPQ: proc not Runnable!\n");
+}
+
+
+struct proc * getRRQProc(){
+	if(rrq.isEmpty()){
+		panic("getRRQProc failed!!");
+	}
+	struct proc * p = rrq.dequeue();
+	return p;
+
+
+}
+
+struct proc * getPQProc(){
+	if (pq.isEmpty()){
+		panic("getPQProc failed!!");
+	}
+	struct proc * p = pq.extractMin();
+	return p;
+
+
+}
+
+struct proc * getExtPQProc(){
+	struct proc * p = pq.extractMin();
+	if(!p){
+		panic("getExtPQProc: Queue is empty!");
+	}
+	struct proc * nextProc =0;
+
+		if(time_quantum_counter % 100 == 0 && !pq.isEmpty()){
+			uint min = MAX_LONG;
+			struct proc *cp;
+
+			for (cp = ptable.proc; cp < &ptable.proc[NPROC]; cp++) {
+				if (cp->state == RUNNABLE) {
+						if (cp->bedTime < min) {
+								nextProc = cp;
+								min = cp->bedTime;
+							 }
+					 }
+
+			 }
+			 if(nextProc == null){
+				 panic("no runnable proc to choose");
+			 }
+			 if(p!=nextProc){
+				 pq.put(p);
+				 if(!pq.extractProc(nextProc)){
+					 panic("RUNNABLE proc not in queue");
+				 }
+			 }
+		}
+		else{
+
+			nextProc =  p;
+		}
+
+	time_quantum_counter++;
+	lastProc = nextProc;
+	return nextProc;
+}
+
 void
 pinit(void)
 {
+	switchFromPolicy = switchFromPolicyArr[pol];
+	signToQ = signToQArr[pol];
+	getProc = getProcArr[pol];
+	isQEmpty = isQEmptyArr[pol];
   initlock(&ptable.lock, "ptable");
 }
 
@@ -48,10 +297,10 @@ struct cpu*
 mycpu(void)
 {
   int apicid, i;
-  
+
   if(readeflags()&FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
@@ -85,9 +334,7 @@ allocproc(void)
 {
   struct proc *p;
   char *sp;
-
   acquire(&ptable.lock);
-
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
     if(p->state == UNUSED)
       goto found;
@@ -100,7 +347,7 @@ found:
   p->pid = nextpid++;
 
   release(&ptable.lock);
-
+	p->priority = DEFAULT_PRIORITY;
   // Allocate kernel stack.
   if((p->kstack = kalloc()) == 0){
     p->state = UNUSED;
@@ -121,6 +368,17 @@ found:
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
+	uint currtick;
+	getTicks(&currtick);
+	p->bedTime = time_quantum_counter;
+	p->readyStartTime = 0;
+	p->startRunningTime = 0;
+	p->ctime = currtick;
+	p->ttime = 0;
+	p->stime = 0;
+	p->rutime = 0;
+	p->retime = 0;
+
 
   return p;
 }
@@ -134,7 +392,7 @@ userinit(void)
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
@@ -160,6 +418,7 @@ userinit(void)
 
   p->state = RUNNABLE;
 
+	signToQ(p, NEW_PROCESS);
   release(&ptable.lock);
 }
 
@@ -226,6 +485,8 @@ fork(void)
 
   np->state = RUNNABLE;
 
+	signToQ(np,NEW_PROCESS);
+
   release(&ptable.lock);
 
   return pid;
@@ -233,9 +494,9 @@ fork(void)
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
-// until its parent calls wait() to find out it exited.
+// until its parent calls wait(0) to find out it exited.
 void
-exit(void)
+exit(int status)
 {
   struct proc *curproc = myproc();
   struct proc *p;
@@ -258,8 +519,10 @@ exit(void)
   curproc->cwd = 0;
 
   acquire(&ptable.lock);
+	curproc->exit_status = status;
 
-  // Parent might be sleeping in wait().
+
+  // Parent might be sleeping in wait(0).
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
@@ -270,22 +533,25 @@ exit(void)
         wakeup1(initproc);
     }
   }
-
+	uint curtick;
+	getTicks(&curtick);
+	curproc->ttime = curtick;
+	curproc->rutime += (curtick - curproc->startRunningTime);
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
-  sched();
+	sched();
   panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
+wait(int * status)
 {
-  struct proc *p;
+	struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
   for(;;){
     // Scan through table looking for exited children.
@@ -305,6 +571,12 @@ wait(void)
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+				p->bedTime = MAX_LONG;
+
+				// discard the status if it's null
+				if(status != null){
+					*status = p->exit_status;
+				}
         release(&ptable.lock);
         return pid;
       }
@@ -317,10 +589,122 @@ wait(void)
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+
     sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+
   }
 }
 
+// Detach : detach the process with pid from current paret to init
+int detach(int pid){
+	struct proc *p;
+	struct proc *curproc = myproc();
+	acquire(&ptable.lock);
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+		if (pid!= p->pid || curproc!= p->parent)
+			continue;
+
+		p->parent = 0;
+		release(&ptable.lock);
+		return 0;
+
+	}
+	release(&ptable.lock);
+	//cprintf("Detach failed, no child proccess with pid %d \n", pid);
+	return -1;
+}
+void priority(int priority){
+
+	if(priority >= min_priority && priority <= max_priority){
+		acquire(&ptable.lock);
+	 	myproc()->priority = priority;
+		release(&ptable.lock);
+ 	}
+ 	//else panic("Priorety is not in allowed range");
+
+}
+
+int wait_stat(int *status, struct perf *performance) {
+	struct proc *p;
+	int havekids, pid;
+	struct proc *curproc = myproc();
+
+	acquire(&ptable.lock);
+	for(;;){
+		// Scan through table looking for exited children.
+		havekids = 0;
+		for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+			if(p->parent != curproc)
+				continue;
+			havekids = 1;
+			if(p->state == ZOMBIE){
+				performance->ctime = p->ctime;
+				performance->ttime = p->ttime;
+				performance->stime = p->stime;
+				performance->retime = p->retime;
+				performance->rutime = p->rutime;
+				// Found one.
+				pid = p->pid;
+				kfree(p->kstack);
+				p->kstack = 0;
+				freevm(p->pgdir);
+				p->pid = 0;
+				p->parent = 0;
+				p->name[0] = 0;
+				p->killed = 0;
+				p->state = UNUSED;
+				p->bedTime = MAX_LONG;
+				p->rutime = 0;
+				p->retime = 0;
+				p->stime = 0;
+				p->ttime = 0;
+				p->ctime = 0;
+
+				// discard the status if it's null
+				if(status != null){
+					*status = p->exit_status;
+				}
+				release(&ptable.lock);
+				return pid;
+			}
+		}
+
+		// No point waiting if we don't have any children.
+		if(!havekids || curproc->killed){
+			release(&ptable.lock);
+			return -1;
+		}
+
+		// Wait for children to exit.  (See wakeup1 call in proc_exit.)
+
+		sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+
+	}
+}
+
+
+
+
+
+void updateMinAccumulator(struct proc* p){
+
+	long long acc_pq, acc_rq;
+
+    int pqSuccess = pq.getMinAccumulator(&acc_pq);
+    int rqSuccess = rpholder.getMinAccumulator(&acc_rq);
+
+    if (pqSuccess == 1 && rqSuccess == 1) {
+        p->accumulator = acc_pq < acc_rq ? acc_pq : acc_rq;
+    } else if (pqSuccess == 1) {
+        p->accumulator = acc_pq;
+    } else if (rqSuccess == 1) {
+        p->accumulator = acc_rq;
+    }
+		else {
+			p->accumulator = 0;
+		}
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -330,41 +714,44 @@ wait(void)
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
 void
-scheduler(void)
-{
-  struct proc *p;
+scheduler(void){
+  struct proc *p=0;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+	uint curtick;
+
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
 
+		if (!isQEmpty()){
+			p = getProc();
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
       switchuvm(p);
+			getTicks(&curtick);
+			p->retime += curtick - p->readyStartTime;
       p->state = RUNNING;
-
+			p->startRunningTime = curtick;
+			rpholder.add(p);
       swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
+			rpholder.remove(p);
+			p->bedTime = time_quantum_counter;
+			switchkvm();
+			c->proc = 0;
+			 // Process is done running for now.
       // It should have changed its p->state before coming back.
-      c->proc = 0;
+
     }
     release(&ptable.lock);
 
   }
 }
-
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -395,8 +782,10 @@ sched(void)
 void
 yield(void)
 {
+	struct proc * p = myproc();
   acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+  p->state = RUNNABLE;
+	signToQ(p, OLD_PROCESS);
   sched();
   release(&ptable.lock);
 }
@@ -421,14 +810,19 @@ forkret(void)
 
   // Return to "caller", actually trapret (see allocproc).
 }
+void getTicks(uint * currtick){
+	  //acquire(&tickslock);
+		*currtick = ticks;
+		//release(&tickslock);
 
+}
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
 void
 sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   if(p == 0)
     panic("sleep");
 
@@ -448,8 +842,15 @@ sleep(void *chan, struct spinlock *lk)
   // Go to sleep.
   p->chan = chan;
   p->state = SLEEPING;
-
-  sched();
+	uint currtick;
+	getTicks(&currtick);
+	p->rutime += (currtick - p->startRunningTime);
+	p->bedTime = currtick;
+	int beforTick = currtick;
+	sched();
+	getTicks(&currtick);
+	int afterTick = currtick;
+	p->stime += (afterTick - beforTick);
 
   // Tidy up.
   p->chan = 0;
@@ -470,8 +871,10 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+    if(p->state == SLEEPING && p->chan == chan){
       p->state = RUNNABLE;
+			signToQ(p,NEW_PROCESS);
+		}
 }
 
 // Wake up all processes sleeping on chan.
@@ -496,8 +899,10 @@ kill(int pid)
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING){
         p->state = RUNNABLE;
+				signToQ(p,NEW_PROCESS);
+			}
       release(&ptable.lock);
       return 0;
     }
diff --git a/proc.h b/proc.h
index 6ad690e..6d97692 100644
--- a/proc.h
+++ b/proc.h
@@ -49,8 +49,19 @@ struct proc {
   void *chan;                    // If non-zero, sleeping on chan
   int killed;                    // If non-zero, have been killed
   struct file *ofile[NOFILE];    // Open files
-  struct inode *cwd;             // Current directory  
+  struct inode *cwd;             // Current directory
   char name[16];                 // Process name (debugging)
+  int exit_status;               // procs exit code assigned to exit call
+  long long accumulator;         // accumulator of priority
+  int priority;                  // process priority
+  uint bedTime;                  // process sleeping time
+  uint readyStartTime;                    // process start to by ready time
+  uint startRunningTime;                   // process start to run time
+  uint ctime;                    // process creation time
+  uint ttime;                    // process termination time
+  long long stime;               // the total time the process spent in the SLEEPING state
+  uint retime;                   // the total time the process spent in the READY state
+  uint rutime;                   // the total time the process spent in the RUNNING state
 };
 
 // Process memory is laid out contiguously, low addresses first:
@@ -58,3 +69,12 @@ struct proc {
 //   original data and bss
 //   fixed-size stack
 //   expandable heap
+
+//performance struct
+struct perf {
+int ctime;
+int ttime;
+int stime;
+int retime;
+int rutime;
+};
diff --git a/rm.c b/rm.c
index 4fd33c8..83c5f36 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/sh.c b/sh.c
index 054bab9..c2ef7aa 100644
--- a/sh.c
+++ b/sh.c
@@ -3,6 +3,7 @@
 #include "types.h"
 #include "user.h"
 #include "fcntl.h"
+#include "stat.h"
 
 // Parsed command representation
 #define EXEC  1
@@ -63,9 +64,16 @@ runcmd(struct cmd *cmd)
   struct listcmd *lcmd;
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
+  int fd;
+  char c[1];
+  char s[512];
+  int stringLocation = 0;
+  char * myCmd;
+  int cmdName = 0;
+
 
   if(cmd == 0)
-    exit();
+    exit(0);
 
   switch(cmd->type){
   default:
@@ -74,17 +82,48 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      exit();
+    exit(0);
+    //Try to exec original command
     exec(ecmd->argv[0], ecmd->argv);
+    printf(2,"returned from exec\n" );
+    //Returned from exec -> Couldn't find cmd in current dir -> try to find with path file
+    fd = open("/path",O_RDONLY);
+    myCmd = ecmd->argv[0];
+    if (myCmd[0] != '/'){
+      while (read(fd,c,1) != 0){
+        if (c[0]!=':'){
+          s[stringLocation] = c[0];
+          stringLocation++;
+        }
+        else{
+          while(myCmd[cmdName] != 0){
+            s[stringLocation] = myCmd[cmdName];
+            stringLocation++;
+            cmdName++;
+          }
+          s[stringLocation] = 0;
+          stringLocation = 0;
+          cmdName = 0;
+          // DEBUG, DELETE LATER:printf(2,"cmd is:%s\n",s);
+          exec(s, ecmd->argv);
+
+          }
+        }
+        printf(2, "exec %s failed\n", ecmd->argv[0]);
+  }
+  else{
     printf(2, "exec %s failed\n", ecmd->argv[0]);
+  }
+  close(fd);
     break;
 
+
   case REDIR:
     rcmd = (struct redircmd*)cmd;
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit();
+      exit(0);
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +132,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait();
+    wait(0);
     runcmd(lcmd->right);
     break;
 
@@ -117,8 +156,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait();
-    wait();
+    wait(0);
+    wait(0);
     break;
 
   case BACK:
@@ -127,7 +166,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit();
+  exit(0);
 }
 
 int
@@ -144,8 +183,12 @@ getcmd(char *buf, int nbuf)
 int
 main(void)
 {
+//TODO:delete LATER
+
+
   static char buf[100];
   int fd;
+  int fdpath;
 
   // Ensure that three file descriptors are open.
   while((fd = open("console", O_RDWR)) >= 0){
@@ -155,6 +198,28 @@ main(void)
     }
   }
 
+
+  //check if path file exists ' create it if not.'
+  int init_path_size=2;
+  char *  init_path= "/:";
+  if(open("path",O_RDONLY ) < 0 ){
+    if((fdpath = open("path", O_CREATE| O_RDWR ))>=0 ){
+      if(write(fdpath,init_path,init_path_size)!=init_path_size){
+        panic("could not write to file");
+      }
+
+    }
+    else {
+      panic("could not create file path");
+    }
+
+  }
+  else{
+    printf(2,"file path exists\n", 18);
+  }
+
+
+
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
@@ -166,16 +231,16 @@ main(void)
     }
     if(fork1() == 0)
       runcmd(parsecmd(buf));
-    wait();
+    wait(0);
   }
-  exit();
+  exit(0);
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit();
+  exit(0);
 }
 
 int
diff --git a/stressfs.c b/stressfs.c
index c0a4743..06a07ca 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait();
+  wait(0);
 
-  exit();
+  exit(0);
 }
diff --git a/syscall.c b/syscall.c
index ee85261..d034244 100644
--- a/syscall.c
+++ b/syscall.c
@@ -25,6 +25,17 @@ fetchint(uint addr, int *ip)
   return 0;
 }
 
+// Fetch the int ptr at addr from the current process.
+// int
+// fetchintptr(uint addr, int **ip)
+// {
+//   struct proc *curproc = myproc();
+//
+//   if(addr >= curproc->sz || addr+4 > curproc->sz)
+//     return -1;
+//   *ip = addr;
+//   return 0;
+// }
 // Fetch the nul-terminated string at addr from the current process.
 // Doesn't actually copy the string - just sets *pp to point at it.
 // Returns length of string, not including nul.
@@ -52,6 +63,7 @@ argint(int n, int *ip)
   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
 }
 
+
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
@@ -60,7 +72,7 @@ argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
+
   if(argint(n, &i) < 0)
     return -1;
   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
@@ -103,6 +115,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_detach(void);
+extern int sys_policy(void);
+extern int sys_priority(void);
+extern int sys_wait_stat(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +142,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_detach]  sys_detach,
+[SYS_policy]  sys_policy,
+[SYS_priority] sys_priority,
+[SYS_wait_stat] sys_wait_stat,
+
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..8e14786 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_detach 22
+#define SYS_policy 23
+#define SYS_priority 24
+#define SYS_wait_stat 25
diff --git a/sysproc.c b/sysproc.c
index 0686d29..e850620 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -16,24 +16,76 @@ sys_fork(void)
 int
 sys_exit(void)
 {
-  exit();
+  int status;
+
+  if(argint(0,&status)<0)
+    return -1;
+  exit(status);
   return 0;  // not reached
 }
 
 int
-sys_wait(void)
+sys_kill(void)
 {
-  return wait();
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
 }
 
 int
-sys_kill(void)
+sys_detach(void)
 {
   int pid;
-
   if(argint(0, &pid) < 0)
     return -1;
-  return kill(pid);
+  return detach(pid);
+}
+
+int
+sys_wait_stat(void)
+{
+  int * status;
+  struct perf * spref;
+  if(argint(0,(int *)(&status))<0 || argptr(1,(char **) &spref , sizeof(spref))<0)
+    return -1;
+
+  return wait_stat(status, spref);
+}
+int
+sys_wait(void)
+{
+  int * status;
+
+  if(argint(0,(int *)(&status))<0 )
+    return -1;
+
+  return wait(status);
+}
+
+int
+sys_policy(void)
+{
+  int poli;
+  if(argint(0, &poli)<0){
+    return -1;
+  }
+  // if(poli != 1 && poli != 2 && poli != 3)
+  //   return -1;
+  poli--;
+  policy(poli);
+  return 0;
+}
+int
+sys_priority(void)
+{
+  int priorityy;
+  if(argint(0, &priorityy)<0){
+    return -1;
+  }
+  priority(priorityy);
+  return 0;
 }
 
 int
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..4e3ca7b
--- /dev/null
+++ b/test.c
@@ -0,0 +1,586 @@
+// //
+// // Created by nadav on 3/13/19.
+// //
+// #include "types.h"
+// #include "user.h"
+// #include "fcntl.h"
+//
+// #define ROUND_ROBIN 1
+// #define PRIORITY 2
+// #define EXTENED_PRIORITY 3
+//
+//
+// struct perf {
+//     int ctime;                     // Creation time
+//     int ttime;                     // Termination time
+//     int stime;                     // The total time spent in the SLEEPING state
+//     int retime;                    // The total time spent in the RUNNABLE state
+//     int rutime;                    // The total time spent in the RUNNING state
+// };
+//
+//
+// typedef boolean (*test_runner)();
+//
+// void run_test(test_runner test, char *name) {
+//     printf(1, "========== Test - %s: Begin ==========\n", name);
+//     boolean result = test();
+//     if (result) {
+//         printf(1, "========== Test - %s: Passed ==========\n", name);
+//     } else {
+//         printf(1, "========== Test - %s: Failed ==========\n", name);
+//     }
+// }
+//
+// boolean assert_equals(int expected, int actual, char *msg) {
+//     if (expected != actual) {
+//         printf(2, "Assert %s failed: expected %d but got %d\n", msg, expected, actual);
+//         return false;
+//     } else return true;
+// }
+//
+//
+// void print_perf(struct perf *performance) {
+//     printf(1, "pref:\n");
+//     printf(1, "\tctime: %d\n", performance->ctime);
+//     printf(1, "\tttime: %d\n", performance->ttime);
+//     printf(1, "\tstime: %d\n", performance->stime);
+//     printf(1, "\tretime: %d\n", performance->retime);
+//     printf(1, "\trutime: %d\n", performance->rutime);
+//     printf(1, "\n\tTurnaround time: %d\n", (performance->ttime - performance->ctime));
+// }
+//
+// int fact(int n) {
+//     if (!n)
+//         return 0;
+//     return n * fact(n - 1);
+// }
+//
+// unsigned long long fact2(unsigned long long n, unsigned long long k) {
+//     start:
+//     if (n == 1) {
+//         return k;
+//     } else {
+//         --n;
+//         k = k * n;
+//         goto start;
+//     }
+//
+//
+// }
+//
+// int fib(int n) {
+//     if (!n)
+//         return 1;
+//     return fib(n - 1) + fib(n - 2);
+// }
+//
+//
+// boolean test_exit_wait() {
+//     int status;
+//     boolean result = true;
+//     int pid;
+//     for (int i = 0; i < 20; ++i) {
+//         pid = fork();
+//         if (pid > 0) {
+//             wait(&status);
+//             result = result && assert_equals(i, status, "exit&wait");
+//             status = -1;
+//         } else {
+//             sleep(3);
+//             exit(i);
+//         }
+//     }
+//     return result;
+// }
+//
+// boolean test_detach() {
+//     int status1;
+//     int status2;
+//     int status3;
+//     int pid;
+//     boolean result1;
+//     boolean result2;
+//     boolean result3;
+//
+//     pid = fork();
+//     if (pid > 0) {
+//         status1 = detach(pid);
+//         result1 = assert_equals(0, status1, "detach - status1");
+//
+//         status2 = detach(pid);
+//         result2 = assert_equals(-1, status2, "detach - status2");
+//
+//         status3 = detach(-10);
+//         result3 = assert_equals(-1, status3, "detach - status3");
+//
+//         return result1 && result2 && result3;
+//     } else {
+//         sleep(100);
+//         exit(0);
+//     }
+// }
+//
+// boolean test_policy_helper(int *priority_mod, int policy) {
+//     int nProcs = 100;
+//     int pid, status;
+//     boolean result = true;
+//     for (int i = 0; i < nProcs; ++i) {
+//         pid = fork();
+//         if (pid < 0) {
+//             break;
+//         } else if (pid == 0) {
+//           //printf(2,"forked child no:%d\n",i);
+//             if (priority_mod) {
+//                 if ((i % *(priority_mod)) == 0 && policy == PRIORITY) {
+//                     priority(1);
+//                 } else {
+//                     priority(i % (*priority_mod));
+//                 }
+//             }
+//             sleep(10);
+//             exit(0);
+//         }
+//     }
+//     for (int j = 0; j < nProcs; ++j) {
+//         wait(&status);
+//         result = result && assert_equals(0, status, "round robin");
+//     }
+//     return result;
+//
+// }
+//
+// boolean test_round_robin_policy() {
+//     return test_policy_helper(null, null);
+//
+// }
+//
+// boolean test_priority_policy() {
+//     int priority_mod = 10;
+//     policy(PRIORITY);
+//     boolean result = test_policy_helper(&priority_mod, PRIORITY);
+//     policy(ROUND_ROBIN);
+//     return result;
+// }
+//
+// boolean test_extended_priority_policy() {
+//     int priority_mod = 10;
+//     policy(EXTENED_PRIORITY);
+//     boolean result = test_policy_helper(&priority_mod, EXTENED_PRIORITY);
+//     policy(ROUND_ROBIN);
+//     return result;
+// }
+//
+// boolean test_performance_helper(int *npriority) {
+//     int pid1;
+//     struct perf perf2;
+//     pid1 = fork();
+//     if (pid1 > 0) {
+//         int status1;
+//         wait_stat(&status1, &perf2);
+//         print_perf(&perf2);
+//     } else {
+//         for (int a = 0; a < 100; ++a) {
+//             int pid;
+//             struct perf perf1;
+//
+//             pid = fork();
+//             // the child pid is pid
+//             if (pid > 0) {
+//                 int status;
+//                 sleep(5);
+//                 wait_stat(&status, &perf1);
+//             } else {
+//                 if (npriority)
+//                     priority(*npriority);
+//                 int sum = 0;
+//                 for (int i = 0; i < 100000000; ++i) {
+//                     for (int j = 0; j < 100000000; ++j) {
+//                         ++sum;
+//                     }
+//                 }
+//                 sleep(5);
+//                 exit(0);
+//             }
+//         }
+//         exit(0);
+//     }
+//     return true;
+// }
+//
+//
+// boolean test_starvation_helper(int npolicy, int npriority) {
+//     boolean result = true;
+//     policy(npolicy);
+//     int nProcs = 10;
+//     int pid_arr[nProcs];
+//     int pid;
+//     memset(&pid_arr, 0, nProcs * sizeof(int));
+//     for (int i = 0; i < nProcs; ++i) {
+//         pid = fork();
+//         if (pid < 0) {
+//             break;
+//         } else if (pid == 0) {
+//             sleep(5);
+//             priority(npriority);
+//             for (;;){
+//             //  printf(1,"inside infinite loop\n" );
+//             }
+//         } else {
+//             pid_arr[i] = pid;
+//         }
+//     }
+//     sleep(100);
+//     for (int j = 0; j < nProcs; ++j) {
+//         if (pid_arr[j] != 0) {
+//             result = result && assert_equals(0, kill(pid_arr[j]), "failed to kill child (yes it does sound horrible)");
+//             wait(null);
+//         }
+//     }
+//    policy(ROUND_ROBIN);
+//     return result;
+// }
+//
+// /**
+//  * test the growth of accumulator
+//  */
+// boolean test_accumulator() {
+//     return test_starvation_helper(PRIORITY, 2);
+// }
+//
+// /** I hope this does test the case of
+//    starvation in extended priority
+//    (where the priority is 0)
+// */
+// boolean test_starvation() {
+//     return test_starvation_helper(EXTENED_PRIORITY, 0);
+// }
+//
+//
+// boolean test_performance_round_robin() {
+//     return test_performance_helper(null);
+// }
+//
+// boolean test_performance_priority() {
+//     policy(PRIORITY);
+//     int npriority = 2;
+//     boolean result = test_performance_helper(&npriority);
+//     policy(ROUND_ROBIN);
+//     return result;
+//
+// }
+//
+// boolean test_performance_extended_priority() {
+//     policy(EXTENED_PRIORITY);
+//     int npriority = 0;
+//     boolean result = test_performance_helper(&npriority);
+//     policy(ROUND_ROBIN);
+//     return result;
+//
+// }
+//
+//
+// int main(void) {
+//   //  run_test(&test_exit_wait, "exit&wait");
+//   //    run_test(&test_detach, "detach");
+//   printf(1,"something\n");
+//   // run_test(test_round_robin_policy, "round robin policy");
+//   // run_test(test_priority_policy, "priority policy");
+//   // run_test(test_extended_priority_policy, "extended priority policy");
+//   // run_test(test_accumulator, "accumulator");
+//   // run_test(test_starvation, "starvation");
+//   run_test(test_performance_round_robin, "performance round robin");
+//   run_test(test_performance_priority, "performance priority");
+//   run_test(test_performance_extended_priority, "performance extended priority");
+//     exit(0);
+// }
+
+//
+// Created by nadav on 3/13/19.
+//
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+
+#define ROUND_ROBIN 1
+#define PRIORITY 2
+#define EXTENED_PRIORITY 3
+
+struct perf {
+    int ctime;                     // Creation time
+    int ttime;                     // Termination time
+    int stime;                     // The total time spent in the SLEEPING state
+    int retime;                    // The total time spent in the RUNNABLE state
+    int rutime;                    // The total time spent in the RUNNING state
+};
+
+
+typedef boolean (test_runner)();
+
+void run_test(test_runner *test, char *name) {
+    printf(1, "========== Test - %s: Begin ==========\n", name);
+    boolean result = (*test)();
+    if (result) {
+        printf(1, "========== Test - %s: Passed ==========\n", name);
+    } else {
+        printf(1, "========== Test - %s: Failed ==========\n", name);
+    }
+}
+
+boolean assert_equals(int expected, int actual, char *msg) {
+    if (expected != actual) {
+        printf(2, "Assert %s failed: expected %d but got %d\n", msg, expected, actual);
+        return false;
+    } else return true;
+}
+
+
+void print_perf(struct perf *performance) {
+    printf(1, "pref:\n");
+    printf(1, "\tctime: %d\n", performance->ctime);
+    printf(1, "\tttime: %d\n", performance->ttime);
+    printf(1, "\tstime: %d\n", performance->stime);
+    printf(1, "\tretime: %d\n", performance->retime);
+    printf(1, "\trutime: %d\n", performance->rutime);
+    printf(1, "\n\tTurnaround time: %d\n", (performance->ttime - performance->ctime));
+}
+
+int fact(int n) {
+    if (!n)
+        return 0;
+    return n * fact(n - 1);
+}
+
+unsigned long long fact2(unsigned long long n, unsigned long long k) {
+    start:
+    if (n == 1) {
+        return k;
+    } else {
+        --n;
+        k = k * n;
+        goto start;
+    }
+
+
+}
+
+int fib(int n) {
+    if (!n)
+        return 1;
+    return fib(n - 1) + fib(n - 2);
+}
+
+
+boolean test_exit_wait() {
+    int status;
+    boolean result = true;
+    int pid;
+    for (int i = 0; i < 20; ++i) {
+        pid = fork();
+        if (pid > 0) {
+            wait(&status);
+            result = result && assert_equals(i, status, "exit&wait");
+            status = -1;
+        } else {
+            sleep(3);
+            exit(i);
+        }
+    }
+    return result;
+}
+
+boolean test_detach() {
+    int status1;
+    int status2;
+    int status3;
+    int pid;
+    boolean result1;
+    boolean result2;
+    boolean result3;
+
+    pid = fork();
+    if (pid > 0) {
+        status1 = detach(pid);
+        result1 = assert_equals(0, status1, "detach - status1");
+
+        status2 = detach(pid);
+        result2 = assert_equals(-1, status2, "detach - status2");
+
+        status3 = detach(-10);
+        result3 = assert_equals(-1, status3, "detach - status3");
+
+        return result1 && result2 && result3;
+    } else {
+        sleep(100);
+        exit(0);
+    }
+}
+
+boolean test_policy_helper(int *priority_mod, int policy) {
+    int nProcs = 100;
+    int pid, status;
+    boolean result = true;
+    for (int i = 0; i < nProcs; ++i) {
+        pid = fork();
+        if (pid < 0) {
+            break;
+        } else if (pid == 0) {
+            if (priority_mod) {
+                if ((i % *(priority_mod)) == 0 && policy == PRIORITY) {
+                    priority(1);
+                } else {
+                    priority(i % (*priority_mod));
+                }
+            }
+            sleep(10);
+            exit(0);
+        }
+    }
+    for (int j = 0; j < nProcs; ++j) {
+        wait(&status);
+        result = result && assert_equals(0, status, "round robin");
+    }
+    return result;
+
+}
+
+boolean test_round_robin_policy() {
+    return test_policy_helper(null, null);
+
+}
+
+boolean test_priority_policy() {
+    int priority_mod = 10;
+    policy(PRIORITY);
+    boolean result = test_policy_helper(&priority_mod, PRIORITY);
+    policy(ROUND_ROBIN);
+    return result;
+}
+
+boolean test_extended_priority_policy() {
+    int priority_mod = 10;
+    policy(EXTENED_PRIORITY);
+    boolean result = test_policy_helper(&priority_mod, EXTENED_PRIORITY);
+    policy(ROUND_ROBIN);
+    return result;
+}
+
+boolean test_performance_helper(int *npriority) {
+    int pid1;
+    struct perf perf2;
+    pid1 = fork();
+    if (pid1 > 0) {
+        int status1;
+        wait_stat(&status1, &perf2);
+        print_perf(&perf2);
+    } else {
+        for (int a = 0; a < 100; ++a) {
+            int pid;
+            struct perf perf1;
+
+            pid = fork();
+            // the child pid is pid
+            if (pid > 0) {
+                int status;
+                sleep(5);
+                wait_stat(&status, &perf1);
+            } else {
+                if (npriority)
+                    priority(*npriority);
+                int sum = 0;
+                for (int i = 0; i < 100000000; ++i) {
+                    for (int j = 0; j < 100000000; ++j) {
+                        ++sum;
+                    }
+                }
+                sleep(5);
+                exit(0);
+            }
+        }
+        exit(0);
+    }
+    return true;
+}
+
+
+boolean test_starvation_helper(int npolicy, int npriority) {
+    boolean result = true;
+    policy(npolicy);
+    int nProcs = 10;
+    int pid_arr[nProcs];
+    int pid;
+    memset(&pid_arr, 0, nProcs * sizeof(int));
+    for (int i = 0; i < nProcs; ++i) {
+        pid = fork();
+        if (pid < 0) {
+            break;
+        } else if (pid == 0) {
+            sleep(5);
+            priority(npriority);
+            for (;;) {};
+        } else {
+            pid_arr[i] = pid;
+        }
+    }
+    sleep(100);
+    for (int j = 0; j < nProcs; ++j) {
+        if (pid_arr[j] != 0) {
+            result = result && assert_equals(0, kill(pid_arr[j]), "failed to kill child (yes it does sound horrible)");
+            wait(null);
+        }
+    }
+    policy(ROUND_ROBIN);
+    return result;
+}
+
+/**
+ * test the growth of accumulator
+ */
+boolean test_accumulator() {
+    return test_starvation_helper(PRIORITY, 2);
+}
+
+/** I hope this does test the case of
+   starvation in extended priority
+   (where the priority is 0)
+*/
+boolean test_starvation() {
+    return test_starvation_helper(EXTENED_PRIORITY, 0);
+}
+
+
+boolean test_performance_round_robin() {
+    return test_performance_helper(null);
+}
+
+boolean test_performance_priority() {
+    policy(PRIORITY);
+    int npriority = 2;
+    boolean result = test_performance_helper(&npriority);
+    policy(ROUND_ROBIN);
+    return result;
+
+}
+
+boolean test_performance_extended_priority() {
+    policy(EXTENED_PRIORITY);
+    int npriority = 0;
+    boolean result = test_performance_helper(&npriority);
+    policy(ROUND_ROBIN);
+    return result;
+
+}
+
+
+int main(void) {
+    run_test(test_exit_wait, "exit&wait");
+    run_test(test_detach, "detach");
+    run_test(test_round_robin_policy, "round robin policy");
+    run_test(test_priority_policy, "priority policy");
+    run_test(test_extended_priority_policy, "extended priority policy");
+    run_test(test_accumulator, "accumulator");
+    run_test(test_starvation, "starvation");
+    run_test(test_performance_round_robin, "performance round robin");
+    run_test(test_performance_priority, "performance priority");
+    run_test(test_performance_extended_priority, "performance extended priority");
+    exit(0);
+}
diff --git a/tests.c b/tests.c
new file mode 100644
index 0000000..c11d4fe
--- /dev/null
+++ b/tests.c
@@ -0,0 +1,177 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+
+
+
+int success=0, fail=0,ans=-2;
+
+void test_exit_wait_success(){
+
+    int pid = fork();
+    if(pid!=0){
+      wait(&ans);
+    }
+    else {
+      exit(1);}
+}
+void test_exit_wait_fail(){
+
+  int pid = fork();
+  if(pid>0){
+    wait(&ans);
+  }
+  else exit(-1);
+}
+void test_detach_success(){
+  int pid;
+  pid = fork();
+  if(pid > 0) {
+   ans = detach(pid);
+
+} else
+  {
+    sleep(10);
+    exit(0);
+  }
+}
+
+void test_detach_fail(){
+  int pid;
+  pid = fork();
+  if(pid > 0) {
+    wait(0);
+   ans = detach(pid+9); // status = -1
+
+  }
+  else
+  {
+    exit(0);
+  }
+
+}
+
+void test_detach_wrong_parent(){
+  int pid;
+  pid = fork();
+  if(pid == 0) {
+      ans = detach(pid); // status = -1
+      exit(0);
+  }
+  else wait(0);
+}
+
+void round_robin_sanity(){
+  int pid,pid2;
+  pid = fork();
+  if(pid>0){
+    pid2=fork();
+    if(pid2==0){
+      int i;sleep(3);
+      for(i=0;i<3;i++){
+
+        write(2,"Going to sleep son 2\n",21);
+        sleep(1);
+        write(2,"woke up son 2\n",16);
+      }
+      write(2,"son 2 exiting\n",16);
+      sleep(1);
+        exit(0);
+    }
+    else {  wait(0);wait(0);}
+  }
+  else{
+    int i;
+    for(i=0;i<3;i++){
+      write(2,"Going to sleep son 1\n",21);
+      sleep(3);
+      write(2,"woke up son 1\n",16);
+    }
+    write(2,"son 1 exiting\n",16);
+    exit(0);
+  }
+}
+void test_3sons(int pol){
+  policy(pol);
+  int pid,pid2,pid3;
+  pid = fork();
+  if(pid>0){
+    sleep(1);
+    pid2=fork();
+    if(pid2>0){
+      sleep(1);
+      pid3=fork();
+      if(pid3 == 0){
+        //sleep(1);
+        int i;
+        for(i=0;i<3;i++){
+          write(2,"Going to sleep son 3\n",21);
+          sleep(1);
+          write(2,"woke up son 3\n",15);
+        }
+        write(2,"son 3 exiting\n",15);
+        sleep(1);
+          exit(0);
+      }
+      else {wait(0);wait(0);wait(0);}
+    }
+    else{
+      sleep(2);
+      int i;
+      for(i=0;i<3;i++){
+        write(2,"Going to sleep son 2\n",21);
+        sleep(1);
+        write(2,"woke up son 2\n",15);
+      }
+      write(2,"son 2 exiting\n",15);
+      sleep(1);
+        exit(0);
+    }
+  }
+  else{
+    sleep(3);
+    int i;
+    for(i=0;i<3;i++){
+      write(2,"Going to sleep son 1\n",21);
+      sleep(1);
+      write(2,"woke up son 1\n",15);
+    }
+    write(2,"son 1 exiting\n",15);
+    exit(0);
+  }
+}
+
+void make_test(void (*f)(void) , int expected ,char * fail_msg){
+
+  f();
+  if(ans == expected)
+    success++;
+  else {
+    fail++;
+    printf(1,"%s\n",fail_msg);
+  }
+
+}
+void some(){
+  printf(2,"start some\n" );
+  policy(2);
+}
+int main(void){
+  //round_robin_sanity();
+
+//  some();
+  for (int i=0;i<20;i++){
+  test_3sons(2);
+}
+
+  //make_test(test_exit_wait_success, 1, "test_exit_wait_success failed\n");
+  //make_test(test_exit_wait_fail, -1 , "test_exit_wait_fail failed\n");
+  //make_test(test_detach_success,0,"test_detach_success failed\n");
+  //make_test(test_detach_fail,-1,"test_detach_fail failed\n");
+  //make_test(test_detach_wrong_parent,-1,"test_detach_wrong_parent failed\n");
+  printf(2,"num of success:%d num of failures: %d\n",success,fail );
+
+  exit(0);
+
+}
diff --git a/trap.c b/trap.c
index 41c66eb..3b4ca82 100644
--- a/trap.c
+++ b/trap.c
@@ -12,7 +12,7 @@
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
-uint ticks;
+/*volatile*/ uint  ticks;
 
 void
 tvinit(void)
@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
-      exit();
+      exit(0);
     myproc()->tf = tf;
     syscall();
     if(myproc()->killed)
-      exit();
+      exit(0);
     return;
   }
 
@@ -98,7 +98,7 @@ trap(struct trapframe *tf)
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
@@ -108,5 +108,5 @@ trap(struct trapframe *tf)
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 }
diff --git a/user.h b/user.h
index 4f99c52..1916c23 100644
--- a/user.h
+++ b/user.h
@@ -1,10 +1,12 @@
 struct stat;
 struct rtcdate;
+struct perf;
+
 
 // system calls
 int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
+int exit(int) __attribute__((noreturn));
+int wait(int * status);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
@@ -23,6 +25,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int detach(int pid);
+void policy(int policy);
+void priority(int priority);
+int wait_stat(int *status, struct perf *performance);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..371d7bd 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(detach)
+SYSCALL(policy)
+SYSCALL(priority)
+SYSCALL(wait_stat)
diff --git a/wc.c b/wc.c
index d6a54df..1d4f708 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit();
+    exit(0);
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/zombie.c b/zombie.c
index ee817da..c96b92d 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit();
+  exit(0);
 }
